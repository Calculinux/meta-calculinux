From a6ae0d7c8a4835aec0e789cf8b1a188a50da039c Mon Sep 17 00:00:00 2001
From: JohnnyonFlame <johnnyonflame@hotmail.com>
Date: Sat, 17 Dec 2022 07:11:20 -0300
Subject: [PATCH] KMSDRM: Added experimental Dumb Buffer support.

---
 cmake/sdlchecks.cmake                 |  32 +++-
 src/video/kmsdrm/SDL_kmsdrmdumb.c     | 228 +++++++++++++++++++++++++
 src/video/kmsdrm/SDL_kmsdrmdyn.c      |   2 +-
 src/video/kmsdrm/SDL_kmsdrmdyn.h      |   9 +
 src/video/kmsdrm/SDL_kmsdrmmouse.c    |  12 +-
 src/video/kmsdrm/SDL_kmsdrmmouse.h    |   4 +
 src/video/kmsdrm/SDL_kmsdrmopengles.c | 151 +++++++++++++++-
 src/video/kmsdrm/SDL_kmsdrmopengles.h |   5 +-
 src/video/kmsdrm/SDL_kmsdrmsym.h      |   5 +-
 src/video/kmsdrm/SDL_kmsdrmvideo.c    | 236 ++++++++++----------------
 src/video/kmsdrm/SDL_kmsdrmvideo.h    |  44 ++++-
 11 files changed, 564 insertions(+), 164 deletions(-)
 create mode 100644 src/video/kmsdrm/SDL_kmsdrmdumb.c

diff --git a/cmake/sdlchecks.cmake b/cmake/sdlchecks.cmake
index ac36cfa2d..343d67ebe 100644
--- a/cmake/sdlchecks.cmake
+++ b/cmake/sdlchecks.cmake
@@ -1321,17 +1321,31 @@ macro(CheckRPI)
 endmacro()
 
 # Requires:
-# - EGL
 # - PkgCheckModules
 # Optional:
+# - EGL
 # - SDL_KMSDRM_SHARED opt
 # - HAVE_SDL_LOADSO opt
 macro(CheckKMSDRM)
   if(SDL_KMSDRM)
-    pkg_check_modules(PKG_KMSDRM libdrm gbm egl)
-    if(PKG_KMSDRM_FOUND AND HAVE_OPENGL_EGL)
+    pkg_check_modules(PKG_KMSDRM libdrm)
+    if(PKG_KMSDRM_FOUND)
+      set(_PKG_KMSDRM_HAVE_EGL FALSE)
+      if(HAVE_OPENGL_EGL)
+        pkg_check_modules(PKG_KMSDRM_EGL gbm egl)
+        if(PKG_KMSDRM_EGL_FOUND)
+          set(_PKG_KMSDRM_HAVE_EGL TRUE)
+        endif()
+      endif()
+
       target_link_directories(sdl-build-options INTERFACE ${PKG_KMSDRM_LIBRARY_DIRS})
+      if(_PKG_KMSDRM_HAVE_EGL)
+        target_link_directories(sdl-build-options INTERFACE ${PKG_KMSDRM_EGL_LIBRARY_DIRS})
+      endif()
       target_include_directories(sdl-build-options SYSTEM INTERFACE "${PKG_KMSDRM_INCLUDE_DIRS}")
+      if(_PKG_KMSDRM_HAVE_EGL)
+        target_include_directories(sdl-build-options SYSTEM INTERFACE "${PKG_KMSDRM_EGL_INCLUDE_DIRS}")
+      endif()
       set(HAVE_KMSDRM TRUE)
       set(HAVE_SDL_VIDEO TRUE)
 
@@ -1339,6 +1353,9 @@ macro(CheckKMSDRM)
       list(APPEND SOURCE_FILES ${KMSDRM_SOURCES})
 
       list(APPEND EXTRA_CFLAGS ${PKG_KMSDRM_CFLAGS})
+      if(_PKG_KMSDRM_HAVE_EGL)
+        list(APPEND EXTRA_CFLAGS ${PKG_KMSDRM_EGL_CFLAGS})
+      endif()
 
       set(SDL_VIDEO_DRIVER_KMSDRM 1)
 
@@ -1347,12 +1364,17 @@ macro(CheckKMSDRM)
       endif()
       if(SDL_KMSDRM_SHARED AND HAVE_SDL_LOADSO)
         FindLibraryAndSONAME(drm LIBDIRS ${PKG_KMSDRM_LIBRARY_DIRS})
-        FindLibraryAndSONAME(gbm LIBDIRS ${PKG_KMSDRM_LIBRARY_DIRS})
         set(SDL_VIDEO_DRIVER_KMSDRM_DYNAMIC "\"${DRM_LIB_SONAME}\"")
-        set(SDL_VIDEO_DRIVER_KMSDRM_DYNAMIC_GBM "\"${GBM_LIB_SONAME}\"")
+        if(_PKG_KMSDRM_HAVE_EGL)
+          FindLibraryAndSONAME(gbm LIBDIRS ${PKG_KMSDRM_EGL_LIBRARY_DIRS})
+          set(SDL_VIDEO_DRIVER_KMSDRM_DYNAMIC_GBM "\"${GBM_LIB_SONAME}\"")
+        endif()
         set(HAVE_KMSDRM_SHARED TRUE)
       else()
         list(APPEND EXTRA_LIBS ${PKG_KMSDRM_LIBRARIES})
+        if(_PKG_KMSDRM_HAVE_EGL)
+          list(APPEND EXTRA_LIBS ${PKG_KMSDRM_EGL_LIBRARIES})
+        endif()
       endif()
     endif()
   endif()
diff --git a/src/video/kmsdrm/SDL_kmsdrmdumb.c b/src/video/kmsdrm/SDL_kmsdrmdumb.c
new file mode 100644
index 000000000..be334abdf
--- /dev/null
+++ b/src/video/kmsdrm/SDL_kmsdrmdumb.c
@@ -0,0 +1,228 @@
+/*
+  Simple DirectMedia Layer
+  Copyright (C) 1997-2022 Sam Lantinga <slouken@libsdl.org>
+
+  This software is provided 'as-is', without any express or implied
+  warranty.  In no event will the authors be held liable for any damages
+  arising from the use of this software.
+
+  Permission is granted to anyone to use this software for any purpose,
+  including commercial applications, and to alter it and redistribute it
+  freely, subject to the following restrictions:
+
+  1. The origin of this software must not be misrepresented; you must not
+     claim that you wrote the original software. If you use this software
+     in a product, an acknowledgment in the product documentation would be
+     appreciated but is not required.
+  2. Altered source versions must be plainly marked as such, and must not be
+     misrepresented as being the original software.
+  3. This notice may not be removed or altered from any source distribution.
+*/
+
+#include "../../SDL_internal.h"
+
+#if SDL_VIDEO_DRIVER_KMSDRM
+
+#include "SDL_log.h"
+
+#include "SDL_kmsdrmvideo.h"
+#include "SDL_kmsdrmdyn.h"
+#include <errno.h>
+#include <fcntl.h>
+#include <sys/mman.h>
+#include <unistd.h>
+
+
+int KMSDRM_Dumb_CreateDumbBuffers(_THIS, SDL_Window *window)
+{
+    int ret;
+    Uint64 has_dumb;
+    SDL_WindowData *windata = ((SDL_WindowData *)window->driverdata);
+    SDL_DisplayData *dispdata = (SDL_DisplayData *)SDL_GetDisplayForWindow(window)->driverdata;
+    SDL_VideoData *viddata = ((SDL_VideoData *)_this->driverdata);
+
+    KMSDRM_DumbBuffer *buffer;
+    struct drm_mode_create_dumb *req_create;
+	struct drm_mode_map_dumb *req_map;
+	struct drm_mode_destroy_dumb *req_destroy_dumb;
+
+    if (viddata->drm_fd < 0)
+        viddata->drm_fd = open(viddata->devpath, O_RDWR | O_CLOEXEC);
+
+    SDL_LogInfo(SDL_LOG_CATEGORY_VIDEO, "KMSDRM: Creating dumb buffers.");
+
+    if (!(KMSDRM_drmGetCap(viddata->drm_fd, DRM_CAP_DUMB_BUFFER, &has_dumb) >= 0 && has_dumb)) {
+        SDL_SetError("KMSDRM: KMSDRM implementation has no dumb buffer caps? (fd: %d)", viddata->drm_fd);
+        return -1;
+    }
+
+    for (int i = 0; i < SDL_arraysize(windata->dumb_buffers); i++) {
+        buffer = &windata->dumb_buffers[i];
+        req_create = &buffer->req_create;
+        req_map = &buffer->req_map;
+        req_destroy_dumb = &buffer->req_destroy_dumb;
+
+        req_create->width = dispdata->fullscreen_mode.hdisplay;
+        req_create->height = dispdata->fullscreen_mode.vdisplay;
+        req_create->bpp = 32; //!! HARDCODED SDL_PIXELFORMAT_ARGB8888
+
+        if (KMSDRM_drmIoctl(viddata->drm_fd, DRM_IOCTL_MODE_CREATE_DUMB, req_create) < 0) {
+            buffer->buf_id = -1;
+            SDL_SetError("KMSDRM: Unable to create dumb buffer.");
+            goto kmsdrm_fail_createfb;
+        }
+
+        req_destroy_dumb->handle = req_create->handle;
+        if ((ret = KMSDRM_drmModeAddFB(viddata->drm_fd, req_create->width, req_create->height, 24, 32, req_create->pitch, req_create->handle, &buffer->buf_id))) {
+            req_create->handle = -1;
+            SDL_SetError("KMSDRM: Unable to create framebuffer: %d.", ret);
+            goto kmsdrm_fail_createfb;
+        }
+
+        req_map->handle = req_create->handle;
+        if (KMSDRM_drmIoctl(viddata->drm_fd, DRM_IOCTL_MODE_MAP_DUMB, req_map) < 0) {
+            SDL_SetError("KMSDRM: Map data request failed.");
+            goto kmsdrm_fail_createfb;
+        }
+
+        buffer->map = mmap(0, req_create->size, PROT_READ | PROT_WRITE, MAP_SHARED, viddata->drm_fd, req_map->offset);
+        if (buffer->map == MAP_FAILED) {
+            SDL_SetError("KMSDRM: Failed to map framebuffer.");
+            goto kmsdrm_fail_createfb;
+        }
+    }
+
+    windata->back_buffer = 0;
+    windata->front_buffer = 1;
+    viddata->dumb_init = SDL_TRUE;
+
+    return 0;
+kmsdrm_fail_createfb:
+    for (int i = 0; i < SDL_arraysize(windata->dumb_buffers); i++) {
+        buffer = &windata->dumb_buffers[i];
+        req_create = &buffer->req_create;
+        req_map = &buffer->req_map;
+        req_destroy_dumb = &buffer->req_destroy_dumb;
+        
+        if (buffer->buf_id > 0)
+            KMSDRM_drmModeRmFB(viddata->drm_fd, buffer->buf_id);
+
+        if (req_create->handle > 0)
+            KMSDRM_drmIoctl(viddata->drm_fd, DRM_IOCTL_MODE_DESTROY_DUMB, req_destroy_dumb);
+
+        if (buffer->map)
+            KMSDRM_drmUnmap(buffer->map, req_create->size);
+    }
+
+    return -1;
+}
+
+int KMSDRM_Dumb_CreateWindowFramebuffer(_THIS, SDL_Window * window, Uint32 * format, void ** pixels, int *pitch)
+{
+    SDL_Surface *surf;
+    SDL_WindowData *windata = ((SDL_WindowData *)window->driverdata);
+    SDL_VideoData *viddata = ((SDL_VideoData *)_this->driverdata);
+
+    const SDL_PixelFormatEnum fmt = SDL_PIXELFORMAT_ARGB8888;
+    /* Not supported when using accelerated renderers. */
+    if (viddata->opengl_mode)
+        return SDL_SetError("Cannot mix dumb buffers with OpenGL.");
+
+    KMSDRM_Dumb_DestroyWindowFramebuffer(_this, window);
+    surf = SDL_CreateRGBSurfaceWithFormat(0, window->w, window->h, 32, fmt);
+    if (!surf) {
+        SDL_SetError("Unable to create window framebuffer.");
+        return -1;
+    }
+
+    *format = fmt;
+    *pixels = surf->pixels;
+    *pitch = surf->pitch;
+    windata->framebuffer = surf;
+
+    return 0;
+}
+
+int KMSDRM_Dumb_UpdateWindowFramebuffer(_THIS, SDL_Window * window, const SDL_Rect * rects, int numrects)
+{
+    SDL_WindowData *windata = ((SDL_WindowData *)window->driverdata);
+    SDL_DisplayData *dispdata = (SDL_DisplayData *)SDL_GetDisplayForWindow(window)->driverdata;
+    SDL_VideoData *viddata = ((SDL_VideoData *)_this->driverdata);
+    KMSDRM_DumbBuffer *buffer = &windata->dumb_buffers[windata->back_buffer];
+    SDL_Surface *surf = windata->framebuffer;
+    int swap, ret;
+
+    if (viddata->opengl_mode)
+        return SDL_SetError("Cannot mix dumb buffers with OpenGL.");
+
+    /* Recreate the GBM / EGL surfaces if the display mode has changed */
+    if (windata->egl_surface_dirty) {
+        KMSDRM_CreateSurfaces(_this, window);
+    }
+
+    if (!viddata->dumb_init)
+        return -1;
+
+    for (int i = 0; i < window->h; i++) {
+        Uint32 *row_db = buffer->map + (i * buffer->req_create.pitch);
+        Uint32 *row_fb = surf->pixels + (i * surf->pitch);
+        SDL_memcpy(row_db, row_fb, window->w * surf->format->BytesPerPixel);
+    }
+
+    ret = KMSDRM_drmModeSetCrtc(viddata->drm_fd, dispdata->crtc->crtc_id,
+                                windata->dumb_buffers[windata->back_buffer].buf_id, 
+                                0, 0, &dispdata->connector->connector_id, 1, &dispdata->mode);
+
+    swap = windata->back_buffer;
+    windata->back_buffer = windata->front_buffer;
+    windata->front_buffer = swap;
+    return ret;
+}
+
+void KMSDRM_Dumb_DestroyWindowFramebuffer(_THIS, SDL_Window * window)
+{
+    SDL_WindowData *windata = ((SDL_WindowData *)window->driverdata);
+    if (windata->framebuffer) {
+        SDL_FreeSurface(windata->framebuffer);
+        windata->framebuffer = NULL;
+    }
+}
+
+void KMSDRM_Dumb_DestroySurfaces(_THIS, SDL_Window *window)
+{
+    SDL_WindowData *windata = ((SDL_WindowData *)window->driverdata);
+    SDL_VideoData *viddata = ((SDL_VideoData *)_this->driverdata);
+    KMSDRM_DumbBuffer *buffer;
+    struct drm_mode_create_dumb *req_create;
+	struct drm_mode_destroy_dumb *req_destroy_dumb;
+
+    if (!viddata->dumb_init)
+        return;
+
+    for (int i = 0; i < SDL_arraysize(windata->dumb_buffers); i++) {
+        buffer = &windata->dumb_buffers[i];
+        req_create = &buffer->req_create;
+        req_destroy_dumb = &buffer->req_destroy_dumb;
+        
+        if (buffer->buf_id > 0)
+            KMSDRM_drmModeRmFB(viddata->drm_fd, buffer->buf_id);
+
+        if (req_create->handle > 0)
+            KMSDRM_drmIoctl(viddata->drm_fd, DRM_IOCTL_MODE_DESTROY_DUMB, req_destroy_dumb);
+
+        if (buffer->map)
+            KMSDRM_drmUnmap(buffer->map, req_create->size);
+
+        buffer->buf_id = -1;
+        req_create->handle = -1;
+        buffer->map = MAP_FAILED;
+    }
+
+    close(viddata->drm_fd);
+    viddata->drm_fd = -1;
+    viddata->dumb_init = SDL_FALSE;
+}
+
+#endif /* SDL_VIDEO_DRIVER_KMSDRM */
+
+/* vi: set ts=4 sw=4 expandtab: */
diff --git a/src/video/kmsdrm/SDL_kmsdrmdyn.c b/src/video/kmsdrm/SDL_kmsdrmdyn.c
index 294739405..326b3e817 100644
--- a/src/video/kmsdrm/SDL_kmsdrmdyn.c
+++ b/src/video/kmsdrm/SDL_kmsdrmdyn.c
@@ -138,7 +138,7 @@ int SDL_KMSDRM_LoadSymbols(void)
 #define SDL_KMSDRM_SYM_OPT(rc, fn, params)  KMSDRM_##fn = (SDL_DYNKMSDRMFN_##fn)KMSDRM_GetSym(#fn, thismod, SDL_FALSE);
 #include "SDL_kmsdrmsym.h"
 
-        if ((SDL_KMSDRM_HAVE_LIBDRM) && (SDL_KMSDRM_HAVE_GBM)) {
+        if ((SDL_KMSDRM_HAVE_LIBDRM)) {
             /* all required symbols loaded. */
             SDL_ClearError();
         } else {
diff --git a/src/video/kmsdrm/SDL_kmsdrmdyn.h b/src/video/kmsdrm/SDL_kmsdrmdyn.h
index 63f39a64c..806f83104 100644
--- a/src/video/kmsdrm/SDL_kmsdrmdyn.h
+++ b/src/video/kmsdrm/SDL_kmsdrmdyn.h
@@ -24,9 +24,13 @@
 
 #include "../../SDL_internal.h"
 
+#include <libdrm/drm.h>
+#include <libdrm/drm_fourcc.h>
 #include <xf86drm.h>
 #include <xf86drmMode.h>
+#if SDL_VIDEO_OPENGL_EGL
 #include <gbm.h>
+#endif
 
 #ifdef __cplusplus
 extern "C" {
@@ -35,6 +39,11 @@ extern "C" {
 int SDL_KMSDRM_LoadSymbols(void);
 void SDL_KMSDRM_UnloadSymbols(void);
 
+/* Externalize if modules were properly loaded */
+#define SDL_KMSDRM_MODULE(modname)       extern int SDL_KMSDRM_HAVE_##modname;
+#include "SDL_kmsdrmsym.h"
+#undef SDL_KMSDRM_MODULE
+
 /* Declare all the function pointers and wrappers... */
 #define SDL_KMSDRM_SYM(rc, fn, params)        \
     typedef rc(*SDL_DYNKMSDRMFN_##fn) params; \
diff --git a/src/video/kmsdrm/SDL_kmsdrmmouse.c b/src/video/kmsdrm/SDL_kmsdrmmouse.c
index c58947663..66051769a 100644
--- a/src/video/kmsdrm/SDL_kmsdrmmouse.c
+++ b/src/video/kmsdrm/SDL_kmsdrmmouse.c
@@ -59,7 +59,7 @@ static SDL_Cursor *KMSDRM_CreateDefaultCursor(void)
 {
     return SDL_CreateCursor(default_cdata, default_cmask, DEFAULT_CWIDTH, DEFAULT_CHEIGHT, DEFAULT_CHOTX, DEFAULT_CHOTY);
 }
-
+#if SDL_VIDEO_OPENGL_EGL
 /* Given a display's driverdata, destroy the cursor BO for it.
    To be called from KMSDRM_DestroyWindow(), as that's where we
    destroy the driverdata for the window's display. */
@@ -207,7 +207,17 @@ cleanup:
     }
     return ret;
 }
+#else
+static int KMSDRM_DumpCursorToBO(SDL_VideoDisplay *display, SDL_Cursor *cursor)
+{
+    return 0;
+}
 
+static int KMSDRM_RemoveCursorFromBO(SDL_VideoDisplay *display)
+{
+    return 0;
+}
+#endif
 /* This is only for freeing the SDL_cursor.*/
 static void KMSDRM_FreeCursor(SDL_Cursor *cursor)
 {
diff --git a/src/video/kmsdrm/SDL_kmsdrmmouse.h b/src/video/kmsdrm/SDL_kmsdrmmouse.h
index b060dd3fb..db41e5271 100644
--- a/src/video/kmsdrm/SDL_kmsdrmmouse.h
+++ b/src/video/kmsdrm/SDL_kmsdrmmouse.h
@@ -24,7 +24,9 @@
 #ifndef SDL_KMSDRM_mouse_h_
 #define SDL_KMSDRM_mouse_h_
 
+#if SDL_VIDEO_OPENGL_EGL
 #include <gbm.h>
+#endif
 
 #define MAX_CURSOR_W 512
 #define MAX_CURSOR_H 512
@@ -46,8 +48,10 @@ typedef struct _KMSDRM_CursorData
 extern void KMSDRM_InitMouse(_THIS, SDL_VideoDisplay *display);
 extern void KMSDRM_QuitMouse(_THIS);
 
+#if SDL_VIDEO_OPENGL_EGL
 extern void KMSDRM_CreateCursorBO(SDL_VideoDisplay *display);
 extern void KMSDRM_DestroyCursorBO(_THIS, SDL_VideoDisplay *display);
+#endif
 extern void KMSDRM_InitCursor(void);
 
 #endif /* SDL_KMSDRM_mouse_h_ */
diff --git a/src/video/kmsdrm/SDL_kmsdrmopengles.c b/src/video/kmsdrm/SDL_kmsdrmopengles.c
index 311586278..5c2aefcb0 100644
--- a/src/video/kmsdrm/SDL_kmsdrmopengles.c
+++ b/src/video/kmsdrm/SDL_kmsdrmopengles.c
@@ -21,7 +21,7 @@
 
 #include "../../SDL_internal.h"
 
-#ifdef SDL_VIDEO_DRIVER_KMSDRM
+#if defined(SDL_VIDEO_DRIVER_KMSDRM) && defined(SDL_VIDEO_OPENGL_EGL)
 
 #include "SDL_log.h"
 #include "SDL_timer.h"
@@ -30,12 +30,103 @@
 #include "SDL_kmsdrmopengles.h"
 #include "SDL_kmsdrmdyn.h"
 #include <errno.h>
+#include <fcntl.h>
+#include <unistd.h>
 
 #ifndef EGL_PLATFORM_GBM_MESA
 #define EGL_PLATFORM_GBM_MESA 0x31D7
 #endif
 
 /* EGL implementation of SDL OpenGL support */
+/* Init the Vulkan-INCOMPATIBLE stuff:
+   Reopen FD, create gbm dev, create dumb buffer and setup display plane.
+   This is to be called late, in WindowCreate(), and ONLY if this is not
+   a Vulkan window.
+   We are doing this so late to allow Vulkan to work if we build a VK window.
+   These things are incompatible with Vulkan, which accesses the same resources
+   internally so they must be free when trying to build a Vulkan surface.
+*/
+int KMSDRM_GBMInit(_THIS, SDL_DisplayData *dispdata)
+{
+    SDL_VideoData *viddata = (SDL_VideoData *)_this->driverdata;
+    int ret = 0;
+
+    if (!SDL_KMSDRM_HAVE_GBM) {
+        return SDL_SetError("Couldn't create gbm device.");
+    }
+
+    /* Reopen the FD! */
+    viddata->drm_fd = open(viddata->devpath, O_RDWR | O_CLOEXEC);
+
+    /* Set the FD we just opened as current DRM master. */
+    KMSDRM_drmSetMaster(viddata->drm_fd);
+
+    /* Create the GBM device. */
+    viddata->gbm_dev = KMSDRM_gbm_create_device(viddata->drm_fd);
+    if (!viddata->gbm_dev) {
+        ret = SDL_SetError("Couldn't create gbm device.");
+    }
+
+    viddata->gbm_init = SDL_TRUE;
+    viddata->dumb_init = SDL_FALSE;
+
+    return ret;
+}
+
+void KMSDRM_GBMDestroySurfaces(_THIS, SDL_Window *window)
+{
+    SDL_WindowData *windata = ((SDL_WindowData *)window->driverdata);
+    SDL_EGL_MakeCurrent(_this, EGL_NO_SURFACE, EGL_NO_CONTEXT);
+
+    if (windata->egl_surface != EGL_NO_SURFACE) {
+        SDL_EGL_DestroySurface(_this, windata->egl_surface);
+        windata->egl_surface = EGL_NO_SURFACE;
+    }
+
+    /***************************/
+    /* Destroy the GBM buffers */
+    /***************************/
+
+    if (windata->bo) {
+        KMSDRM_gbm_surface_release_buffer(windata->gs, windata->bo);
+        windata->bo = NULL;
+    }
+
+    if (windata->next_bo) {
+        KMSDRM_gbm_surface_release_buffer(windata->gs, windata->next_bo);
+        windata->next_bo = NULL;
+    }
+
+    /***************************/
+    /* Destroy the GBM surface */
+    /***************************/
+
+    if (windata->gs) {
+        KMSDRM_gbm_surface_destroy(windata->gs);
+        windata->gs = NULL;
+    }
+}
+
+/* Deinit the Vulkan-incompatible KMSDRM stuff. */
+void KMSDRM_GBMDeinit(_THIS, SDL_DisplayData *dispdata)
+{
+    SDL_VideoData *viddata = ((SDL_VideoData *)_this->driverdata);
+
+    /* Destroy GBM device. GBM surface is destroyed by DestroySurfaces(),
+       already called when we get here. */
+    if (viddata->gbm_dev) {
+        KMSDRM_gbm_device_destroy(viddata->gbm_dev);
+        viddata->gbm_dev = NULL;
+    }
+
+    /* Finally close DRM FD. May be reopen on next non-vulkan window creation. */
+    if (viddata->drm_fd >= 0) {
+        close(viddata->drm_fd);
+        viddata->drm_fd = -1;
+    }
+
+    viddata->gbm_init = SDL_FALSE;
+}
 
 void KMSDRM_GLES_DefaultProfileConfig(_THIS, int *mask, int *major, int *minor)
 {
@@ -86,6 +177,60 @@ SDL_EGL_CreateContext_impl(KMSDRM)
     return 0;
 }
 
+int KMSDRM_GLES_InitWindow(_THIS, SDL_Window *window)
+{
+    int ret;
+    SDL_DisplayData *dispdata = (SDL_DisplayData *)SDL_GetDisplayForWindow(window)->driverdata;
+    SDL_VideoDisplay *display = SDL_GetDisplayForWindow(window);
+    NativeDisplayType egl_display;
+
+    /* After SDL_CreateWindow, most SDL2 programs will do SDL_CreateRenderer(),
+       which will in turn call GL_CreateRenderer() or GLES2_CreateRenderer().
+       In order for the GL_CreateRenderer() or GLES2_CreateRenderer() call to
+       succeed without an unnecessary window re-creation, we must:
+       -Mark the window as being OPENGL
+       -Load the GL library (which can't be done until the GBM device has been
+       created, so we have to do it here instead of doing it on VideoInit())
+       and mark it as loaded by setting gl_config.driver_loaded to 1.
+       So if you ever see KMSDRM_CreateWindow() to be called two times in tests,
+       don't be shy to debug GL_CreateRenderer() or GLES2_CreateRenderer()
+       to find out why!
+    */
+
+    /* Reopen FD, create gbm dev, setup display plane, etc,.
+        but only when we come here for the first time,
+        and only if it's not a VK window. */
+    ret = KMSDRM_GBMInit(_this, dispdata);
+    if (ret != 0) {
+        return SDL_SetError("Can't init GBM on window creation.");
+    }
+
+    /* Manually load the GL library. KMSDRM_EGL_LoadLibrary() has already
+       been called by SDL_CreateWindow() but we don't do anything there,
+       our KMSDRM_EGL_LoadLibrary() is a dummy precisely to be able to load it here.
+       If we let SDL_CreateWindow() load the lib, it would be loaded
+       before we call KMSDRM_GBMInit(), causing all GLES programs to fail. */
+    if (!_this->egl_data) {
+        egl_display = (NativeDisplayType)((SDL_VideoData *)_this->driverdata)->gbm_dev;
+        if (SDL_EGL_LoadLibrary(_this, NULL, egl_display, EGL_PLATFORM_GBM_MESA) < 0) {
+            /* Try again with OpenGL ES 2.0 */
+            _this->gl_config.profile_mask = SDL_GL_CONTEXT_PROFILE_ES;
+            _this->gl_config.major_version = 2;
+            _this->gl_config.minor_version = 0;
+            if (SDL_EGL_LoadLibrary(_this, NULL, egl_display, EGL_PLATFORM_GBM_MESA) < 0) {
+                return SDL_SetError("Can't load EGL/GL library on window creation.");
+            }
+        }
+
+        _this->gl_config.driver_loaded = 1;
+    }
+
+    /* Create the cursor BO for the display of this window,
+        now that we know this is not a VK window. */
+    KMSDRM_CreateCursorBO(display);
+    return 0;
+}
+
 int KMSDRM_GLES_SwapWindow(_THIS, SDL_Window *window)
 {
     SDL_WindowData *windata = ((SDL_WindowData *)window->driverdata);
@@ -209,6 +354,6 @@ int KMSDRM_GLES_SwapWindow(_THIS, SDL_Window *window)
 
 SDL_EGL_MakeCurrent_impl(KMSDRM)
 
-#endif /* SDL_VIDEO_DRIVER_KMSDRM */
+#endif /* defined(SDL_VIDEO_DRIVER_KMSDRM) && defined(SDL_VIDEO_OPENGL_EGL) */
 
-    /* vi: set ts=4 sw=4 expandtab: */
+/* vi: set ts=4 sw=4 expandtab: */
diff --git a/src/video/kmsdrm/SDL_kmsdrmopengles.h b/src/video/kmsdrm/SDL_kmsdrmopengles.h
index 9307066e3..0584ea6bb 100644
--- a/src/video/kmsdrm/SDL_kmsdrmopengles.h
+++ b/src/video/kmsdrm/SDL_kmsdrmopengles.h
@@ -23,7 +23,7 @@
 #ifndef SDL_kmsdrmopengles_h_
 #define SDL_kmsdrmopengles_h_
 
-#ifdef SDL_VIDEO_DRIVER_KMSDRM
+#if defined(SDL_VIDEO_DRIVER_KMSDRM) && defined(SDL_VIDEO_OPENGL_EGL)
 
 #include "../SDL_sysvideo.h"
 #include "../SDL_egl_c.h"
@@ -38,10 +38,11 @@ extern void KMSDRM_GLES_DefaultProfileConfig(_THIS, int *mask, int *major, int *
 extern int KMSDRM_GLES_SetSwapInterval(_THIS, int interval);
 extern int KMSDRM_GLES_LoadLibrary(_THIS, const char *path);
 extern SDL_GLContext KMSDRM_GLES_CreateContext(_THIS, SDL_Window *window);
+extern int KMSDRM_GLES_InitWindow(_THIS, SDL_Window *window);
 extern int KMSDRM_GLES_SwapWindow(_THIS, SDL_Window *window);
 extern int KMSDRM_GLES_MakeCurrent(_THIS, SDL_Window *window, SDL_GLContext context);
 
-#endif /* SDL_VIDEO_DRIVER_KMSDRM */
+#endif /* defined(SDL_VIDEO_DRIVER_KMSDRM) && defined(SDL_VIDEO_OPENGL_EGL) */
 
 #endif /* SDL_kmsdrmopengles_h_ */
 
diff --git a/src/video/kmsdrm/SDL_kmsdrmsym.h b/src/video/kmsdrm/SDL_kmsdrmsym.h
index b0be627f1..7c6d1e1d4 100644
--- a/src/video/kmsdrm/SDL_kmsdrmsym.h
+++ b/src/video/kmsdrm/SDL_kmsdrmsym.h
@@ -39,6 +39,7 @@
 
 
 SDL_KMSDRM_MODULE(LIBDRM)
+SDL_KMSDRM_SYM(int,drmIoctl,(int fd, unsigned long request, void *arg))
 SDL_KMSDRM_SYM(void,drmModeFreeResources,(drmModeResPtr ptr))
 SDL_KMSDRM_SYM(void,drmModeFreeFB,(drmModeFBPtr ptr))
 SDL_KMSDRM_SYM(void,drmModeFreeCrtc,(drmModeCrtcPtr ptr))
@@ -57,6 +58,7 @@ SDL_KMSDRM_SYM_OPT(int,drmModeAddFB2,(int fd, uint32_t width, uint32_t height,
                          uint32_t pixel_format, const uint32_t bo_handles[4],
                          const uint32_t pitches[4], const uint32_t offsets[4],
                          uint32_t *buf_id, uint32_t flags))
+SDL_KMSDRM_SYM(int,drmUnmap,(drmAddress address, drmSize size))
 
 SDL_KMSDRM_SYM_OPT(int,drmModeAddFB2WithModifiers,(int fd, uint32_t width,
                          uint32_t height, uint32_t pixel_format, const uint32_t bo_handles[4],
@@ -106,7 +108,7 @@ SDL_KMSDRM_SYM(int,drmModeSetPlane,(int fd, uint32_t plane_id, uint32_t crtc_id,
                                     uint32_t src_x, uint32_t src_y,
                                     uint32_t src_w, uint32_t src_h))
 /* Planes stuff ends. */
-
+#if SDL_VIDEO_OPENGL_EGL
 SDL_KMSDRM_MODULE(GBM)
 SDL_KMSDRM_SYM(int,gbm_device_is_format_supported,(struct gbm_device *gbm,
                                                    uint32_t format, uint32_t usage))
@@ -138,6 +140,7 @@ SDL_KMSDRM_SYM_OPT(int,gbm_bo_get_plane_count,(struct gbm_bo *bo))
 SDL_KMSDRM_SYM_OPT(uint32_t,gbm_bo_get_offset,(struct gbm_bo *bo, int plane))
 SDL_KMSDRM_SYM_OPT(uint32_t,gbm_bo_get_stride_for_plane,(struct gbm_bo *bo, int plane))
 SDL_KMSDRM_SYM_OPT(union gbm_bo_handle,gbm_bo_get_handle_for_plane,(struct gbm_bo *bo, int plane))
+#endif
 
 #undef SDL_KMSDRM_MODULE
 #undef SDL_KMSDRM_SYM
diff --git a/src/video/kmsdrm/SDL_kmsdrmvideo.c b/src/video/kmsdrm/SDL_kmsdrmvideo.c
index 8f080c202..b7ebe7410 100644
--- a/src/video/kmsdrm/SDL_kmsdrmvideo.c
+++ b/src/video/kmsdrm/SDL_kmsdrmvideo.c
@@ -280,6 +280,7 @@ static SDL_VideoDevice *KMSDRM_CreateDevice(void)
     device->DestroyWindow = KMSDRM_DestroyWindow;
     device->GetWindowWMInfo = KMSDRM_GetWindowWMInfo;
 
+#if SDL_VIDEO_OPENGL_EGL
     device->GL_LoadLibrary = KMSDRM_GLES_LoadLibrary;
     device->GL_GetProcAddress = KMSDRM_GLES_GetProcAddress;
     device->GL_UnloadLibrary = KMSDRM_GLES_UnloadLibrary;
@@ -290,6 +291,11 @@ static SDL_VideoDevice *KMSDRM_CreateDevice(void)
     device->GL_SwapWindow = KMSDRM_GLES_SwapWindow;
     device->GL_DeleteContext = KMSDRM_GLES_DeleteContext;
     device->GL_DefaultProfileConfig = KMSDRM_GLES_DefaultProfileConfig;
+#endif
+
+    device->CreateWindowFramebuffer = KMSDRM_Dumb_CreateWindowFramebuffer;
+    device->UpdateWindowFramebuffer = KMSDRM_Dumb_UpdateWindowFramebuffer;
+    device->DestroyWindowFramebuffer = KMSDRM_Dumb_DestroyWindowFramebuffer;
 
 #ifdef SDL_VIDEO_VULKAN
     device->Vulkan_LoadLibrary = KMSDRM_Vulkan_LoadLibrary;
@@ -320,6 +326,7 @@ VideoBootStrap KMSDRM_bootstrap = {
     NULL /* no ShowMessageBox implementation */
 };
 
+#if SDL_VIDEO_OPENGL_EGL
 static void KMSDRM_FBDestroyCallback(struct gbm_bo *bo, void *data)
 {
     KMSDRM_FBInfo *fb_info = (KMSDRM_FBInfo *)data;
@@ -495,6 +502,7 @@ SDL_bool KMSDRM_WaitPageflip(_THIS, SDL_WindowData *windata)
 
     return SDL_TRUE;
 }
+#endif /* SDL_VIDEO_OPENGL_EGL */
 
 /* Given w, h and refresh rate, returns the closest DRM video mode
    available on the DRM connector of the display.
@@ -1031,55 +1039,6 @@ cleanup:
    These things are incompatible with Vulkan, which accesses the same resources
    internally so they must be free when trying to build a Vulkan surface.
 */
-static int KMSDRM_GBMInit(_THIS, SDL_DisplayData *dispdata)
-{
-    SDL_VideoData *viddata = (SDL_VideoData *)_this->driverdata;
-    int ret = 0;
-
-    /* Reopen the FD if we weren't able to drop master on the original one */
-    if (viddata->drm_fd < 0) {
-        viddata->drm_fd = open(viddata->devpath, O_RDWR | O_CLOEXEC);
-        if (viddata->drm_fd < 0) {
-            return SDL_SetError("Could not reopen %s", viddata->devpath);
-        }
-    }
-
-    /* Set the FD as current DRM master. */
-    KMSDRM_drmSetMaster(viddata->drm_fd);
-
-    /* Create the GBM device. */
-    viddata->gbm_dev = KMSDRM_gbm_create_device(viddata->drm_fd);
-    if (!viddata->gbm_dev) {
-        ret = SDL_SetError("Couldn't create gbm device.");
-    }
-
-    viddata->gbm_init = SDL_TRUE;
-
-    return ret;
-}
-
-/* Deinit the Vulkan-incompatible KMSDRM stuff. */
-static void KMSDRM_GBMDeinit(_THIS, SDL_DisplayData *dispdata)
-{
-    SDL_VideoData *viddata = ((SDL_VideoData *)_this->driverdata);
-
-    /* Destroy GBM device. GBM surface is destroyed by DestroySurfaces(),
-       already called when we get here. */
-    if (viddata->gbm_dev) {
-        KMSDRM_gbm_device_destroy(viddata->gbm_dev);
-        viddata->gbm_dev = NULL;
-    }
-
-    /* Finally drop DRM master if possible, otherwise close DRM FD.
-       May be reopened on next non-vulkan window creation. */
-    if (viddata->drm_fd >= 0 && !KMSDRM_DropMaster(_this)) {
-        close(viddata->drm_fd);
-        viddata->drm_fd = -1;
-    }
-
-    viddata->gbm_init = SDL_FALSE;
-}
-
 static void KMSDRM_DestroySurfaces(_THIS, SDL_Window *window)
 {
     SDL_VideoData *viddata = ((SDL_VideoData *)_this->driverdata);
@@ -1112,38 +1071,13 @@ static void KMSDRM_DestroySurfaces(_THIS, SDL_Window *window)
         SDL_LogError(SDL_LOG_CATEGORY_VIDEO, "Could not restore CRTC");
     }
 
-    /***************************/
-    /* Destroy the EGL surface */
-    /***************************/
-
-    SDL_EGL_MakeCurrent(_this, EGL_NO_SURFACE, EGL_NO_CONTEXT);
-
-    if (windata->egl_surface != EGL_NO_SURFACE) {
-        SDL_EGL_DestroySurface(_this, windata->egl_surface);
-        windata->egl_surface = EGL_NO_SURFACE;
-    }
-
-    /***************************/
-    /* Destroy the GBM buffers */
-    /***************************/
-
-    if (windata->bo) {
-        KMSDRM_gbm_surface_release_buffer(windata->gs, windata->bo);
-        windata->bo = NULL;
-    }
-
-    if (windata->next_bo) {
-        KMSDRM_gbm_surface_release_buffer(windata->gs, windata->next_bo);
-        windata->next_bo = NULL;
-    }
-
-    /***************************/
-    /* Destroy the GBM surface */
-    /***************************/
-
-    if (windata->gs) {
-        KMSDRM_gbm_surface_destroy(windata->gs);
-        windata->gs = NULL;
+#if SDL_VIDEO_OPENGL_EGL
+    if (viddata->opengl_mode) {
+        KMSDRM_GBMDestroySurfaces(_this, window);
+    } else
+#endif
+    {
+        KMSDRM_Dumb_DestroySurfaces(_this, window);
     }
 }
 
@@ -1188,27 +1122,33 @@ static void KMSDRM_DirtySurfaces(SDL_Window *window)
    that we create here. */
 int KMSDRM_CreateSurfaces(_THIS, SDL_Window *window)
 {
-    SDL_VideoData *viddata = ((SDL_VideoData *)_this->driverdata);
+    SDL_VideoData *viddata = (SDL_VideoData *)_this->driverdata;
     SDL_WindowData *windata = (SDL_WindowData *)window->driverdata;
     SDL_VideoDisplay *display = SDL_GetDisplayForWindow(window);
     SDL_DisplayData *dispdata = (SDL_DisplayData *)display->driverdata;
+    SDL_bool is_init = SDL_FALSE;
 
+#if SDL_VIDEO_OPENGL_EGL
     uint32_t surface_fmt = GBM_FORMAT_ARGB8888;
     uint32_t surface_flags = GBM_BO_USE_SCANOUT | GBM_BO_USE_RENDERING;
-
     EGLContext egl_context;
+#endif
 
     int ret = 0;
 
-    /* If the current window already has surfaces, destroy them before creating other. */
+    if (windata->dumb_buffers[0].buf_id > 0) {
+        is_init = SDL_TRUE;
+    }
+
+#if SDL_VIDEO_OPENGL_EGL
     if (windata->gs) {
-        KMSDRM_DestroySurfaces(_this, window);
+        is_init = SDL_TRUE;
     }
+#endif
 
-    if (!KMSDRM_gbm_device_is_format_supported(viddata->gbm_dev,
-                                               surface_fmt, surface_flags)) {
-        SDL_LogWarn(SDL_LOG_CATEGORY_VIDEO,
-                    "GBM surface format not supported. Trying anyway.");
+    /* If the current window already has surfaces, destroy them before creating other. */
+    if (is_init) {
+        KMSDRM_DestroySurfaces(_this, window);
     }
 
     /* The KMSDRM backend doesn't always set the mode the higher-level code in
@@ -1221,6 +1161,25 @@ int KMSDRM_CreateSurfaces(_THIS, SDL_Window *window)
     display->current_mode.refresh_rate = dispdata->mode.vrefresh;
     display->current_mode.format = SDL_PIXELFORMAT_ARGB8888;
 
+    if (!viddata->opengl_mode) {
+        if (KMSDRM_Dumb_CreateDumbBuffers(_this, window)) {
+            return SDL_SetError("KMSDRM: Failed to create window Dumb Buffer.");
+        }
+
+        SDL_SendWindowEvent(window, SDL_WINDOWEVENT_RESIZED,
+                            dispdata->mode.hdisplay, dispdata->mode.vdisplay);
+
+        windata->egl_surface_dirty = SDL_FALSE;
+        return 0;
+    }
+
+#if SDL_VIDEO_OPENGL_EGL
+    if (!KMSDRM_gbm_device_is_format_supported(viddata->gbm_dev,
+                                               surface_fmt, surface_flags)) {
+        SDL_LogWarn(SDL_LOG_CATEGORY_VIDEO,
+                    "GBM surface format not supported. Trying anyway.");
+    }
+
     windata->gs = KMSDRM_gbm_surface_create(viddata->gbm_dev,
                                             dispdata->mode.hdisplay, dispdata->mode.vdisplay,
                                             surface_fmt, surface_flags);
@@ -1261,6 +1220,10 @@ cleanup:
     }
 
     return ret;
+#else
+    SDL_SetError("KMSDRM: OpenGL requested but EGL support is disabled.");
+    return -1;
+#endif
 }
 
 #ifdef SDL_INPUT_LINUXEV
@@ -1304,6 +1267,8 @@ int KMSDRM_VideoInit(_THIS)
 
     viddata->video_init = SDL_FALSE;
     viddata->gbm_init = SDL_FALSE;
+    viddata->dumb_init = SDL_FALSE;
+    viddata->opengl_mode = SDL_FALSE;
 
     /* Get KMSDRM resources info and store what we need. Getting and storing
        this info isn't a problem for VK compatibility.
@@ -1423,29 +1388,33 @@ void KMSDRM_DestroyWindow(_THIS, SDL_Window *window)
 
     viddata = windata->viddata;
 
-    if (!is_vulkan && viddata->gbm_init) {
+    if (!is_vulkan && (viddata->gbm_init || viddata->dumb_init)) {
 
-        /* Destroy cursor GBM BO of the display of this window. */
-        KMSDRM_DestroyCursorBO(_this, SDL_GetDisplayForWindow(window));
+#if SDL_VIDEO_OPENGL_EGL
+        if (viddata->opengl_mode) {
+            /* Destroy cursor GBM BO of the display of this window. */
+            KMSDRM_DestroyCursorBO(_this, SDL_GetDisplayForWindow(window));
+        }
+#endif
 
-        /* Destroy GBM surface and buffers. */
+        /* Destroy GBM/dumb surfaces and buffers. */
         KMSDRM_DestroySurfaces(_this, window);
 
-        /* Unload library and deinit GBM, but only if this is the last window.
-           Note that this is the right comparision because num_windows could be 1
-           if there is a complete window, or 0 if we got here from SDL_CreateWindow()
-           because KMSDRM_CreateWindow() returned an error so the window wasn't
-           added to the windows list. */
+        /* Unload libraries and deinit resources only if this is the last window. */
         if (viddata->num_windows <= 1) {
 
-            /* Unload EGL/GL library and free egl_data.  */
+#if SDL_VIDEO_OPENGL_EGL
             if (_this->egl_data) {
                 SDL_EGL_UnloadLibrary(_this);
                 _this->gl_config.driver_loaded = 0;
             }
 
-            /* Free display plane, and destroy GBM device. */
-            KMSDRM_GBMDeinit(_this, dispdata);
+            if (viddata->gbm_init) {
+                KMSDRM_GBMDeinit(_this, dispdata);
+            }
+#endif
+
+            viddata->opengl_mode = SDL_FALSE;
         }
 
     } else {
@@ -1490,9 +1459,12 @@ int KMSDRM_CreateWindow(_THIS, SDL_Window *window)
     SDL_VideoData *viddata = (SDL_VideoData *)_this->driverdata;
     SDL_VideoDisplay *display = SDL_GetDisplayForWindow(window);
     SDL_DisplayData *dispdata = display->driverdata;
-    SDL_bool is_vulkan = window->flags & SDL_WINDOW_VULKAN; /* Is this a VK window? */
+    SDL_bool is_vulkan = (window->flags & SDL_WINDOW_VULKAN) == SDL_WINDOW_VULKAN; /* Is this a VK window? */
+    SDL_bool is_opengl = (window->flags & SDL_WINDOW_OPENGL) == SDL_WINDOW_OPENGL; /* Is this a GL window? */
     SDL_bool vulkan_mode = viddata->vulkan_mode;            /* Do we have any Vulkan windows? */
+#if SDL_VIDEO_OPENGL_EGL
     NativeDisplayType egl_display;
+#endif
     drmModeModeInfo *mode;
     int ret = 0;
 
@@ -1504,6 +1476,8 @@ int KMSDRM_CreateWindow(_THIS, SDL_Window *window)
 
     /* Setup driver data for this window */
     windata->viddata = viddata;
+    windata->dumb_buffers[0].buf_id = -1;
+    windata->dumb_buffers[1].buf_id = -1;
     window->driverdata = windata;
 
     /* Do we want a double buffering scheme to get low video lag? */
@@ -1514,58 +1488,20 @@ int KMSDRM_CreateWindow(_THIS, SDL_Window *window)
 
     if (!is_vulkan && !vulkan_mode) { /* NON-Vulkan block. */
 
-        /* Maybe you didn't ask for an OPENGL window, but that's what you will get.
-           See following comments on why. */
-        window->flags |= SDL_WINDOW_OPENGL;
-
-        if (!(viddata->gbm_init)) {
-
-            /* After SDL_CreateWindow, most SDL2 programs will do SDL_CreateRenderer(),
-               which will in turn call GL_CreateRenderer() or GLES2_CreateRenderer().
-               In order for the GL_CreateRenderer() or GLES2_CreateRenderer() call to
-               succeed without an unnecessary window re-creation, we must:
-               -Mark the window as being OPENGL
-               -Load the GL library (which can't be done until the GBM device has been
-                created, so we have to do it here instead of doing it on VideoInit())
-                and mark it as loaded by setting gl_config.driver_loaded to 1.
-               So if you ever see KMSDRM_CreateWindow() to be called two times in tests,
-               don't be shy to debug GL_CreateRenderer() or GLES2_CreateRenderer()
-               to find out why!
-             */
-
-            /* Reopen FD, create gbm dev, setup display plane, etc,.
-               but only when we come here for the first time,
-               and only if it's not a VK window. */
-            ret = KMSDRM_GBMInit(_this, dispdata);
-            if (ret != 0) {
-                return SDL_SetError("Can't init GBM on window creation.");
-            }
-        }
-
-        /* Manually load the GL library. KMSDRM_EGL_LoadLibrary() has already
-           been called by SDL_CreateWindow() but we don't do anything there,
-           our KMSDRM_EGL_LoadLibrary() is a dummy precisely to be able to load it here.
-           If we let SDL_CreateWindow() load the lib, it would be loaded
-           before we call KMSDRM_GBMInit(), causing all GLES programs to fail. */
-        if (!_this->egl_data) {
-            egl_display = (NativeDisplayType)((SDL_VideoData *)_this->driverdata)->gbm_dev;
-            if (SDL_EGL_LoadLibrary(_this, NULL, egl_display, EGL_PLATFORM_GBM_MESA) < 0) {
-                /* Try again with OpenGL ES 2.0 */
-                _this->gl_config.profile_mask = SDL_GL_CONTEXT_PROFILE_ES;
-                _this->gl_config.major_version = 2;
-                _this->gl_config.minor_version = 0;
-                if (SDL_EGL_LoadLibrary(_this, NULL, egl_display, EGL_PLATFORM_GBM_MESA) < 0) {
-                    return SDL_SetError("Can't load EGL/GL library on window creation.");
+        if (is_opengl) {
+#if SDL_VIDEO_OPENGL_EGL
+            if (!(viddata->gbm_init)) {
+                ret = KMSDRM_GLES_InitWindow(_this, window);
+                if (ret != 0) {
+                    return ret;
                 }
+                viddata->opengl_mode = SDL_TRUE;
             }
-
-            _this->gl_config.driver_loaded = 1;
+#else
+            return SDL_SetError("Unable to create GL window, EGL not enabled.");
+#endif
         }
 
-        /* Create the cursor BO for the display of this window,
-           now that we know this is not a VK window. */
-        KMSDRM_CreateCursorBO(display);
-
         /* Create and set the default cursor for the display
            of this window, now that we know this is not a VK window. */
         KMSDRM_InitMouse(_this, display);
diff --git a/src/video/kmsdrm/SDL_kmsdrmvideo.h b/src/video/kmsdrm/SDL_kmsdrmvideo.h
index 16431435d..ffe455ba3 100644
--- a/src/video/kmsdrm/SDL_kmsdrmvideo.h
+++ b/src/video/kmsdrm/SDL_kmsdrmvideo.h
@@ -28,10 +28,19 @@
 
 #include <fcntl.h>
 #include <unistd.h>
+#include <libdrm/drm.h>
+#include <libdrm/drm_fourcc.h>
 #include <xf86drm.h>
 #include <xf86drmMode.h>
+#if SDL_VIDEO_OPENGL_EGL
 #include <gbm.h>
 #include <EGL/egl.h>
+#else
+struct gbm_device;
+struct gbm_surface;
+struct gbm_bo;
+typedef void *EGLSurface;
+#endif
 
 #ifndef DRM_FORMAT_MOD_INVALID
 #define DRM_FORMAT_MOD_INVALID 0x00ffffffffffffffULL
@@ -82,6 +91,7 @@ typedef struct SDL_VideoData
 
     SDL_bool video_init;             /* Has VideoInit succeeded? */
     SDL_bool vulkan_mode;            /* Are we in Vulkan mode? One VK window is enough to be. */
+    SDL_bool opengl_mode;            /* Are we in OpenGL mode? One GL window is enough to be. */
     SDL_bool async_pageflip_support; /* Does the hardware support async. pageflips? */
 
     SDL_Window **windows;
@@ -91,7 +101,7 @@ typedef struct SDL_VideoData
     /* Even if we have several displays, we only have to
        open 1 FD and create 1 gbm device. */
     SDL_bool gbm_init;
-
+    SDL_bool dumb_init;
 } SDL_VideoData;
 
 typedef struct SDL_DisplayModeData
@@ -121,6 +131,14 @@ typedef struct SDL_DisplayData
     SDL_bool default_cursor_init;
 } SDL_DisplayData;
 
+typedef struct KMSDRM_DumbBuffer {
+    struct drm_mode_destroy_dumb req_destroy_dumb;
+    struct drm_mode_create_dumb req_create;
+    struct drm_mode_map_dumb req_map;
+    Uint32 buf_id;
+    void *map;
+} KMSDRM_DumbBuffer;
+
 typedef struct SDL_WindowData
 {
     SDL_VideoData *viddata;
@@ -128,9 +146,18 @@ typedef struct SDL_WindowData
        what supports the EGL surface on the driver side, so all these surfaces and buffers
        are expected to be here, in the struct pointed by SDL_Window driverdata pointer:
        this one. So don't try to move these to dispdata!  */
+
+#if SDL_VIDEO_OPENGL_EGL
     struct gbm_surface *gs;
     struct gbm_bo *bo;
     struct gbm_bo *next_bo;
+#endif
+
+    // Maybe union these with the gs/bo/next_bo definitions?
+    KMSDRM_DumbBuffer dumb_buffers[2];
+    int front_buffer;
+    int back_buffer;
+    SDL_Surface *framebuffer;
 
     SDL_bool waiting_for_flip;
     SDL_bool double_buffer;
@@ -150,6 +177,9 @@ int KMSDRM_CreateSurfaces(_THIS, SDL_Window *window);
 KMSDRM_FBInfo *KMSDRM_FBFromBO(_THIS, struct gbm_bo *bo);
 KMSDRM_FBInfo *KMSDRM_FBFromBO2(_THIS, struct gbm_bo *bo, int w, int h);
 SDL_bool KMSDRM_WaitPageflip(_THIS, SDL_WindowData *windata);
+#if SDL_VIDEO_OPENGL_EGL
+void KMSDRM_CreateCursorBO(SDL_VideoDisplay *display);
+#endif
 
 /****************************************************************************/
 /* SDL_VideoDevice functions declaration                                    */
@@ -182,6 +212,7 @@ SDL_bool KMSDRM_GetWindowWMInfo(_THIS, SDL_Window * window,
                              struct SDL_SysWMinfo *info);
 
 /* OpenGL/OpenGL ES functions */
+#if SDL_VIDEO_OPENGL_EGL
 int KMSDRM_GLES_LoadLibrary(_THIS, const char *path);
 void *KMSDRM_GLES_GetProcAddress(_THIS, const char *proc);
 void KMSDRM_GLES_UnloadLibrary(_THIS);
@@ -189,8 +220,19 @@ SDL_GLContext KMSDRM_GLES_CreateContext(_THIS, SDL_Window *window);
 int KMSDRM_GLES_MakeCurrent(_THIS, SDL_Window *window, SDL_GLContext context);
 int KMSDRM_GLES_SetSwapInterval(_THIS, int interval);
 int KMSDRM_GLES_GetSwapInterval(_THIS);
+int KMSDRM_GLES_InitWindow(_THIS, SDL_Window *window);
 int KMSDRM_GLES_SwapWindow(_THIS, SDL_Window *window);
 void KMSDRM_GLES_DeleteContext(_THIS, SDL_GLContext context);
+void KMSDRM_GBMDeinit(_THIS, SDL_DisplayData *dispdata);
+void KMSDRM_GBMDestroySurfaces(_THIS, SDL_Window *window);
+#endif
+
+/* Dumb Buffer functions */
+int KMSDRM_Dumb_CreateDumbBuffers(_THIS, SDL_Window *window);
+int KMSDRM_Dumb_CreateWindowFramebuffer(_THIS, SDL_Window * window, Uint32 * format, void ** pixels, int *pitch);
+int KMSDRM_Dumb_UpdateWindowFramebuffer(_THIS, SDL_Window * window, const SDL_Rect * rects, int numrects);
+void KMSDRM_Dumb_DestroyWindowFramebuffer(_THIS, SDL_Window * window);
+void KMSDRM_Dumb_DestroySurfaces(_THIS, SDL_Window *window);
 
 #endif /* __SDL_KMSDRMVIDEO_H__ */
 
-- 
2.51.0

