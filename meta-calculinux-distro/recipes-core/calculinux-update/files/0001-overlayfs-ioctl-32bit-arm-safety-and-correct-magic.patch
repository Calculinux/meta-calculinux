From: meta-calculinux <noreply@calculinux.org>
Subject: [PATCH] overlayfs: ioctl 32-bit ARM safety and correct magic numbers

- Use ctypes.create_string_buffer and addressof for stable pointer; pack
  as 64-bit (struct.pack 'QII') so kernel receives correct layout on 32-bit ARM.
- Compute ioctl numbers via _IOW('O', nr, 16) to match kernel UAPI.
- Add _validate_ioctl_struct_size() on module load.

Signed-off-by: meta-calculinux <noreply@calculinux.org>

--- a/src/calculinux_update/opkg/overlayfs.py
+++ b/src/calculinux_update/opkg/overlayfs.py
@@ -24,6 +24,7 @@ NOTE: The ioctl automatically invalidates dentries, so no remount is needed.
 """
 
 from __future__ import annotations
+import ctypes
 import errno
 import fcntl
 import logging
@@ -78,8 +79,46 @@ def find_overlay_mount_point(path: str) -> str:
     return best_match if best_match else "/"
 
-OVL_IOC_RESTORE_LOWER = 0x400C4F01 # _IOW('O', 1, ...)
-OVL_IOC_IS_RESTORABLE = 0x800C4F02 # _IOR('O', 2, ...)
+# ioctl encoding (matches kernel _IOW macro)
+_IOC_NONE = 0
+_IOC_WRITE = 1
+_IOC_NRBITS = 8
+_IOC_TYPEBITS = 8
+_IOC_SIZEBITS = 14
+_IOC_DIRBITS = 2
+_IOC_NRSHIFT = 0
+_IOC_TYPESHIFT = _IOC_NRSHIFT + _IOC_NRBITS
+_IOC_SIZESHIFT = _IOC_TYPESHIFT + _IOC_TYPEBITS
+_IOC_DIRSHIFT = _IOC_SIZESHIFT + _IOC_SIZEBITS
+
+def _IOW(type_char: str, nr: int, size: int) -> int:
+    return (_IOC_WRITE << _IOC_DIRSHIFT) | (ord(type_char) << _IOC_TYPESHIFT) | (nr << _IOC_NRSHIFT) | (size << _IOC_SIZESHIFT)
+
+# struct ovl_restore_lower_args: aligned_u64 (8) + u32 (4) + u32 (4) = 16 bytes
+OVL_IOC_RESTORE_LOWER = _IOW('O', 1, 16)
+OVL_IOC_IS_RESTORABLE = _IOW('O', 2, 16)
+
+def _validate_ioctl_struct_size() -> None:
+    import sys
+    test_ptr = 0x12345678 if sys.maxsize <= 2**32 else 0x123456789ABCDEF0
+    test_args = struct.pack('QII', test_ptr, 100, 0)
+    if len(test_args) != 16:
+        raise RuntimeError(
+            f"ioctl struct size mismatch: expected 16 bytes, got {len(test_args)}. "
+            f"Architecture: {'32-bit' if sys.maxsize <= 2**32 else '64-bit'}"
+        )
+    LOGGER.debug("ioctl struct validation passed (16 bytes on %s)", '32-bit' if sys.maxsize <= 2**32 else '64-bit')
+
+_validate_ioctl_struct_size()
 
 
 def check_file_restorability(mount_point: str, path: str) -> FileRestorability:
@@ -94,9 +133,12 @@ def check_file_restorability(mount_point: str, path: str) -> FileRestorability:
     """
     try:
         with open(mount_point, 'r') as f:
-            path_bytes = path.encode('utf-8')
-            args = struct.pack('QII', id(path_bytes), len(path_bytes), 0)
+            path_bytes = path.encode('utf-8') + b'\0'
+            buf = ctypes.create_string_buffer(path_bytes)
+            path_ptr = ctypes.addressof(buf)
+            path_len = len(path.encode('utf-8'))
+            args = struct.pack('QII', path_ptr, path_len, 0)
             fcntl.ioctl(f.fileno(), OVL_IOC_IS_RESTORABLE, args)
         return FileRestorability.WHITEOUT
     except OSError as e:
@@ -119,9 +161,12 @@ def restore_lower_via_ioctl(mount_point: str, path: str) -> bool:
     """
     try:
         with open(mount_point, 'r') as f:
-            path_bytes = path.encode('utf-8')
-            # Use id(path_bytes) for pointer, but this is only valid for the duration of the call
-            args = struct.pack('QII', id(path_bytes), len(path_bytes), 0)
+            path_bytes = path.encode('utf-8') + b'\0'
+            buf = ctypes.create_string_buffer(path_bytes)
+            path_ptr = ctypes.addressof(buf)
+            path_len = len(path.encode('utf-8'))
+            args = struct.pack('QII', path_ptr, path_len, 0)
             fcntl.ioctl(f.fileno(), OVL_IOC_RESTORE_LOWER, args)
         return True
     except OSError as e:
