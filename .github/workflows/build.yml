name: Build Calculinux Images and Packages

on:
  push:
    branches: [ main, develop ]
    tags: [ 'v*' ]
  pull_request:
    branches: [ main ]
  workflow_dispatch:
    inputs:
      sync_all_packages:
        description: 'Sync all packages (not just newly built ones)'
        required: false
        type: boolean
        default: false

env:
  # Yocto build directories that need persistent storage
  DL_DIR: ${{ github.workspace }}/../yocto-cache/downloads
  SSTATE_DIR: ${{ github.workspace }}/../yocto-cache/sstate-cache
  # Package repository storage
  OPKG_REPO_DIR: /mnt/opkg-repo

permissions:
  contents: write  # Needed for creating releases

# To add a new machine configuration, do something similar to the following:
# 
# matrix:
#   machine: [luckfox-lyra, rpi4]  # Add rpi4 here
#   include:
#     - machine: luckfox-lyra
#       name: "Luckfox Lyra Bundle"
#       kas_file: "kas-luckfox-lyra-bundle.yaml"
#       target: "calculinux-bundle"
#       dockerfile: "Dockerfile.aarch64"
#     - machine: rpi4  # Add new machine config
#       name: "Raspberry Pi 4 Bundle"
#       kas_file: "kas-rpi4-bundle.yaml"
#       target: "calculinux-bundle"
#       dockerfile: "Dockerfile.arm64"
  
jobs:
  build:
    name: Build Yocto Images and Packages
    runs-on: [self-hosted, Linux, X64]
    
    strategy:
      fail-fast: false
      matrix:
        machine: [luckfox-lyra]
        include:
          - machine: luckfox-lyra
            name: "Luckfox Lyra Bundle"
            kas_file: "kas-luckfox-lyra-bundle.yaml"
            target: "calculinux-bundle"
            dockerfile: "Dockerfile.aarch64"

    steps:
    - name: Checkout repository
      uses: actions/checkout@v4
      with:
        fetch-depth: 0

    - name: Set up build environment
      run: |
        # Create cache directories if they don't exist
        mkdir -p $DL_DIR $SSTATE_DIR
        
        # Verify package repository storage exists
        if [ ! -d "$OPKG_REPO_DIR" ]; then
          echo "ERROR: Package repository storage $OPKG_REPO_DIR not found"
          echo "Please ensure storage is mounted at /mnt/opkg-repo"
          exit 1
        fi
        
        # Clean up any leftover containers and images from previous builds
        docker system prune -f || true
        
        # Show disk space before build
        df -h

    - name: Determine feed configuration
      id: feed-config
      run: |
        if [ "${{ github.ref_name }}" = "main" ]; then
          # Use distro codename for stable releases (e.g., walnascar, scarthgap)
          DISTRO_CODENAME=$(./kas-container shell ${{ matrix.kas_file }} -c "bitbake -e | grep '^DISTRO_CODENAME=' | cut -d'\"' -f2")
          echo "feed_name=${DISTRO_CODENAME}" >> $GITHUB_OUTPUT
          echo "subfolder=continuous" >> $GITHUB_OUTPUT
          echo "is_prerelease=false" >> $GITHUB_OUTPUT
          echo "is_tagged_release=false" >> $GITHUB_OUTPUT
        elif [ "${{ github.ref_name }}" = "develop" ]; then
          # Use "develop" for all development builds
          echo "feed_name=develop" >> $GITHUB_OUTPUT
          echo "subfolder=continuous" >> $GITHUB_OUTPUT
          echo "is_prerelease=false" >> $GITHUB_OUTPUT
          echo "is_tagged_release=false" >> $GITHUB_OUTPUT
        elif [[ "${{ github.ref }}" =~ ^refs/tags/ ]]; then
          # Tagged releases - check if this is actually a tag
          DISTRO_CODENAME=$(./kas-container shell ${{ matrix.kas_file }} -c "bitbake -e | grep '^DISTRO_CODENAME=' | cut -d'\"' -f2")
          echo "feed_name=${DISTRO_CODENAME}" >> $GITHUB_OUTPUT
          echo "subfolder=release" >> $GITHUB_OUTPUT
          # Check if this is a prerelease (contains rc, beta, or alpha)
          if [[ "${{ github.ref_name }}" =~ (rc|beta|alpha) ]]; then
            echo "is_prerelease=true" >> $GITHUB_OUTPUT
          else
            echo "is_prerelease=false" >> $GITHUB_OUTPUT
          fi
          echo "is_tagged_release=true" >> $GITHUB_OUTPUT
        else
          # Pull requests or other refs - don't publish
          echo "feed_name=${DISTRO_CODENAME}" >> $GITHUB_OUTPUT
          echo "subfolder=branch" >> $GITHUB_OUTPUT
          echo "is_prerelease=false" >> $GITHUB_OUTPUT
          echo "is_tagged_release=false" >> $GITHUB_OUTPUT
        fi
        
        echo "Feed configuration complete"

    - name: Build Yocto image and packages
      run: |
        echo "Building ${{ matrix.name }} using ${{ matrix.kas_file }}"
        echo "This will build:"
        echo "  - ${{ matrix.target }} (base image with overlayfs)"
        echo "  - packagegroup-meta-calculinux-apps (IPK packages)"
        echo ""
        echo "All packages install to /usr (standard paths)"
        echo "Runtime: /usr is overlayfs - base in lower layer, user packages in upper layer"
        
        # Run the build with kas-container
        ./kas-container build ${{ matrix.kas_file }}

    - name: Collect build artifacts (images)
      run: |
        echo "Collecting build artifacts..."
        
        # Find the build directory
        BUILD_DIR=$(find build -name "tmp" -type d | head -1 | sed 's|/tmp||')
        DEPLOY_DIR="${BUILD_DIR}/tmp/deploy/images/${{ matrix.machine }}"
        
        echo "Deploy directory: $DEPLOY_DIR"
        
        if [ -d "$DEPLOY_DIR" ]; then
          # Create artifacts directory
          mkdir -p artifacts
          
          # Copy image files
          find "$DEPLOY_DIR" -name "*.wic.gz" -o -name "*.wic.bz2" -o -name "*.wic.xz" | \
            xargs -I {} cp {} artifacts/ || true
          
          # Copy update bundles (RAUC bundles)
          find "$DEPLOY_DIR" -name "*.raucb" | \
            xargs -I {} cp {} artifacts/ || true
          
          # Copy other important files
          find "$DEPLOY_DIR" -name "*.manifest" -o -name "*.testdata.json" | \
            xargs -I {} cp {} artifacts/ || true
          
          # List what we collected
          echo "Collected artifacts:"
          ls -la artifacts/
        else
          echo "Deploy directory not found: $DEPLOY_DIR"
          echo "Available directories:"
          find build -type d -name "deploy" || true
        fi

    - name: Collect build artifacts (packages)
      run: |
        echo "Collecting IPK packages..."
        
        # Find build directory
        BUILD_DIR=$(find build -name "tmp" -type d | head -1)
        DEPLOY_IPK_DIR="${BUILD_DIR}/deploy/ipk"
        
        if [ -d "$DEPLOY_IPK_DIR" ]; then
          PACKAGE_COUNT=$(find "$DEPLOY_IPK_DIR" -name "*.ipk" -type f | wc -l)
          echo "Found $PACKAGE_COUNT IPK packages"
          
          # Create packages directory in artifacts
          mkdir -p artifacts/packages
          
          # Copy all packages maintaining architecture structure
          cp -r "$DEPLOY_IPK_DIR"/* artifacts/packages/
          
          echo "Collected packages:"
          ls -la artifacts/packages/
        else
          echo "Warning: No IPK packages directory found"
        fi

    - name: Sync packages to repository
      if: github.ref == 'refs/heads/main' || github.ref == 'refs/heads/develop'
      run: |
        echo "Syncing packages to repository..."
        
        # Determine feed path based on branch
        if [ "${{ github.ref_name }}" = "main" ]; then
          # Use distro codename for stable releases
          DISTRO_CODENAME=$(./kas-container shell ${{ matrix.kas_file }} -c "bitbake -e | grep '^DISTRO_CODENAME=' | cut -d'\"' -f2")
          FEED_PATH="ipk/${DISTRO_CODENAME}"
          echo "Publishing to stable feed: $FEED_PATH"
        else
          # Use "develop" for development builds
          FEED_PATH="ipk/develop"
          echo "Publishing to development feed: $FEED_PATH"
        fi
        
        # Create target directory
        FEED_DIR="$OPKG_REPO_DIR/$FEED_PATH"
        mkdir -p "$FEED_DIR"
        
        # Determine sync strategy based on workflow input
        SYNC_ALL="${{ inputs.sync_all_packages }}"
        if [ "$SYNC_ALL" = "true" ]; then
          echo "Syncing ALL packages (manual full sync requested)"
          BUILD_START_TIME=0
        else
          # Record the build start time (subtract 5 minutes for safety margin)
          BUILD_START_TIME=$(date -d '5 minutes ago' +%s)
          echo "Only syncing packages modified after: $(date -d @$BUILD_START_TIME)"
        fi
        
        # Sync packages
        SYNCED=0
        SKIPPED=0
        
        if [ -d "artifacts/packages" ]; then
          for arch_dir in artifacts/packages/*/; do
            if [ -d "$arch_dir" ]; then
              arch=$(basename "$arch_dir")
              arch_dir_target="$FEED_DIR/$arch"
              
              mkdir -p "$arch_dir_target"
              echo "Processing architecture: $arch"
              
              # Process all packages
              while IFS= read -r -d '' ipk_file; do
                package_name=$(basename "$ipk_file")
                target_file="$arch_dir_target/$package_name"
                file_mtime=$(stat -c %Y "$ipk_file")
                
                # Sync if package is newly built OR missing from target
                if [ "$file_mtime" -ge "$BUILD_START_TIME" ] || [ ! -f "$target_file" ]; then
                  if [ "$file_mtime" -ge "$BUILD_START_TIME" ]; then
                    echo "  Syncing newly built package: $package_name"
                  else
                    echo "  Syncing missing package: $package_name"
                  fi
                  cp "$ipk_file" "$arch_dir_target/"
                  SYNCED=$((SYNCED + 1))
                else
                  SKIPPED=$((SKIPPED + 1))
                fi
              done < <(find "$arch_dir" -name "*.ipk" -type f -print0)
              
              # Copy package indexes if they exist
              if [ -f "$arch_dir/Packages" ]; then
                echo "  Copying package index for $arch"
                cp "$arch_dir/Packages" "$arch_dir_target/"
              fi
              if [ -f "$arch_dir/Packages.gz" ]; then
                cp "$arch_dir/Packages.gz" "$arch_dir_target/"
              fi
            fi
          done
          
          echo "Packages synced: $SYNCED (newly built)"
          echo "Packages skipped: $SKIPPED (from sstate-cache)"
          echo "Total available: $((SYNCED + SKIPPED))"
          
          # Show package counts by architecture
          for arch_dir in "$FEED_DIR"/*/; do
            if [ -d "$arch_dir" ]; then
              arch=$(basename "$arch_dir")
              count=$(find "$arch_dir" -name "*.ipk" -type f | wc -l)
              size=$(du -sh "$arch_dir" | cut -f1)
              echo "  $arch: $count packages ($size)"
            fi
          done
          
          echo "Packages available at: https://opkg.calculinux.org/$FEED_PATH/"
        else
          echo "Warning: No packages found to sync"
        fi

    - name: Generate package indexes
      if: github.ref == 'refs/heads/main' || github.ref == 'refs/heads/develop'
      run: |
        # Determine feed path based on branch
        if [ "${{ github.ref_name }}" = "main" ]; then
          DISTRO_CODENAME=$(./kas-container shell ${{ matrix.kas_file }} -c "bitbake -e | grep '^DISTRO_CODENAME=' | cut -d'\"' -f2")
          FEED_PATH="ipk/${DISTRO_CODENAME}"
        else
          FEED_PATH="ipk/develop"
        fi
        
        FEED_DIR="$OPKG_REPO_DIR/$FEED_PATH"
        
        echo "Generating Packages.gz files for feed: $FEED_PATH"
        
        for arch_dir in "$FEED_DIR"/*/; do
          if [ -d "$arch_dir" ]; then
            arch=$(basename "$arch_dir")
            echo "Generating Packages.gz for architecture: $arch"
            
            cd "$arch_dir"
            
            # Generate Packages file
            opkg-make-index -p Packages .
            
            # Compress to Packages.gz
            gzip -f Packages
            
            # Verify the file was created
            if [ -f "Packages.gz" ]; then
              echo "  Successfully generated Packages.gz for $arch"
            else
              echo "  ERROR: Failed to generate Packages.gz for $arch"
              exit 1
            fi
            
            cd - > /dev/null
          fi
        done
        
        echo "Package index generation complete"

    - name: Publish artifacts to webserver
      if: github.ref == 'refs/heads/main' || github.ref == 'refs/heads/develop' || steps.feed-config.outputs.is_tagged_release == 'true'
      run: |
        echo "Publishing artifacts to webserver..."
        
        FEED_NAME="${{ steps.feed-config.outputs.feed_name }}"
        SUBFOLDER="${{ steps.feed-config.outputs.subfolder }}"
        UPDATE_DIR="$OPKG_REPO_DIR/update/$FEED_NAME/$SUBFOLDER"
        IMAGE_DIR="$OPKG_REPO_DIR/image/$FEED_NAME/$SUBFOLDER"
        IS_TAGGED_RELEASE="${{ steps.feed-config.outputs.is_tagged_release }}"
        IS_PRERELEASE="${{ steps.feed-config.outputs.is_prerelease }}"
        TAG_NAME="${{ github.ref_name }}"
        
        # Create target directories
        mkdir -p "$UPDATE_DIR" "$IMAGE_DIR"
        
        if [ "$IS_TAGGED_RELEASE" = "true" ]; then
          echo "Publishing tagged release artifacts..."
          
          # Find the specific RAUC bundle and WIC image files
          RAUCB_FILE=$(find artifacts -name "calculinux-bundle-${{ matrix.machine }}.raucb" | head -1)
          WIC_FILE=$(find artifacts -name "calculinux-image-${{ matrix.machine }}.rootfs.wic.gz" | head -1)
          
          if [ -n "$RAUCB_FILE" ]; then
            # Copy RAUC bundle with versioned name
            cp "$RAUCB_FILE" "$UPDATE_DIR/calculinux-bundle-${{ matrix.machine }}-$TAG_NAME.raucb"
            echo "Published RAUC bundle: calculinux-bundle-${{ matrix.machine }}-$TAG_NAME.raucb"
            
            # If not a prerelease, also copy with original name for latest release
            if [ "$IS_PRERELEASE" = "false" ]; then
              cp "$RAUCB_FILE" "$UPDATE_DIR/calculinux-bundle-${{ matrix.machine }}.raucb"
              echo "Published RAUC bundle: calculinux-bundle-${{ matrix.machine }}.raucb (latest)"
            fi
          else
            echo "Warning: calculinux-bundle-${{ matrix.machine }}.raucb not found"
          fi
          
          if [ -n "$WIC_FILE" ]; then
            # Copy WIC image with versioned name
            cp "$WIC_FILE" "$IMAGE_DIR/calculinux-image-${{ matrix.machine }}.rootfs-$TAG_NAME.wic.gz"
            echo "Published WIC image: calculinux-image-${{ matrix.machine }}.rootfs-$TAG_NAME.wic.gz"
            
            # If not a prerelease, also copy with original name for latest release
            if [ "$IS_PRERELEASE" = "false" ]; then
              cp "$WIC_FILE" "$IMAGE_DIR/calculinux-image-${{ matrix.machine }}.rootfs.wic.gz"
              echo "Published WIC image: calculinux-image-${{ matrix.machine }}.rootfs.wic.gz (latest)"
            fi
          else
            echo "Warning: calculinux-image-${{ matrix.machine }}.rootfs.wic.gz not found"
          fi
        else
          echo "Publishing continuous development artifacts..."
          
          # Copy RAUC bundles to update directory
          if ls artifacts/*.raucb 1> /dev/null 2>&1; then
            echo "Copying RAUC bundles to $UPDATE_DIR"
            cp artifacts/*.raucb "$UPDATE_DIR/"
            echo "Published RAUC bundles:"
            ls -la "$UPDATE_DIR"/*.raucb
          else
            echo "No RAUC bundles found to publish"
          fi
          
          # Copy WIC images to image directory
          if ls artifacts/*.wic.gz 1> /dev/null 2>&1; then
            echo "Copying WIC images to $IMAGE_DIR"
            cp artifacts/*.wic.gz "$IMAGE_DIR/"
            echo "Published WIC images:"
            ls -la "$IMAGE_DIR"/*.wic.gz
          else
            echo "No WIC images found to publish"
          fi
        fi
        
        echo "Artifacts published successfully"

    - name: Generate build information
      run: |
        # Create build info file
        cat > artifacts/build-info.txt << EOF
        Build Information
        =================
        Repository: ${{ github.repository }}
        Commit: ${{ github.sha }}
        Branch/Tag: ${{ github.ref_name }}
        Build Date: $(date -u)
        Configuration: ${{ matrix.name }}
        Machine: ${{ matrix.machine }}
        Target: ${{ matrix.target }}
        Kas File: ${{ matrix.kas_file }}
        Dockerfile: ${{ matrix.dockerfile }}
        Workflow: ${{ github.workflow }}
        Run Number: ${{ github.run_number }}
        EOF
        
        # Add git information if available
        if git log -1 --format="%H %s" >> artifacts/build-info.txt 2>/dev/null; then
          echo "Last Commit: $(git log -1 --format='%H %s')" >> artifacts/build-info.txt
        fi

    - name: Upload artifacts
      uses: actions/upload-artifact@v4
      if: always()
      with:
        name: calculinux-${{ matrix.machine }}-${{ github.run_number }}
        path: artifacts/
        retention-days: 30

    - name: Create release
      if: steps.feed-config.outputs.is_tagged_release == 'true'
      uses: softprops/action-gh-release@v1
      with:
        files: artifacts/*
        generate_release_notes: true
        draft: false
        prerelease: ${{ steps.feed-config.outputs.is_prerelease == 'true' }}

    - name: Show disk space after build
      if: always()
      run: |
        echo "Disk space after build:"
        df -h
        
        echo "Cache directory sizes:"
        du -sh $DL_DIR $SSTATE_DIR || true

    - name: Cleanup
      if: always()
      run: |
        # Clean up build directory but preserve caches
        rm -rf build/tmp/work/* || true
        
        # Clean up docker containers and images
        docker system prune -f || true
        
        # Remove our custom image to save space
        docker rmi kas-custom:latest || true
