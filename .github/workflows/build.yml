name: Build Calculinux Images and Packages

on:
  push:
    branches: [ main, develop ]
    tags: [ 'v*' ]
  pull_request:
    branches: [ main ]
  workflow_dispatch:
    inputs:
      sync_all_packages:
        description: 'Sync all packages (not just newly built ones)'
        required: false
        type: boolean
        default: false

env:
  # Yocto build directories that need persistent storage
  DL_DIR: ${{ github.workspace }}/../yocto-cache/downloads
  SSTATE_DIR: ${{ github.workspace }}/../yocto-cache/sstate-cache
  # Package repository storage
  OPKG_REPO_DIR: /mnt/opkg-repo

permissions:
  contents: write      # Needed for creating releases
  pull-requests: write # Needed for commenting on PRs

# To add a new machine configuration, do something similar to the following:
# 
# matrix:
#   machine: [luckfox-lyra, rpi4]  # Add rpi4 here
#   include:
#     - machine: luckfox-lyra
#       name: "Luckfox Lyra Bundle"
#       kas_file: "kas-luckfox-lyra-bundle.yaml"
#       target: "calculinux-bundle"
#       dockerfile: "Dockerfile.aarch64"
#     - machine: rpi4  # Add new machine config
#       name: "Raspberry Pi 4 Bundle"
#       kas_file: "kas-rpi4-bundle.yaml"
#       target: "calculinux-bundle"
#       dockerfile: "Dockerfile.arm64"
  
jobs:
  build:
    name: Build Yocto Images and Packages
    runs-on: [self-hosted, Linux, X64]
    
    strategy:
      fail-fast: false
      matrix:
        machine: [luckfox-lyra]
        include:
          - machine: luckfox-lyra
            name: "Luckfox Lyra Bundle"
            kas_file: "kas-luckfox-lyra-bundle.yaml"
            target: "calculinux-bundle"
            dockerfile: "Dockerfile.aarch64"

    steps:
    - name: Checkout repository
      uses: actions/checkout@v4
      with:
        fetch-depth: 0

    - name: Set up build environment
      run: |
        # Create cache directories if they don't exist
        mkdir -p $DL_DIR $SSTATE_DIR
        
        # Verify package repository storage exists
        if [ ! -d "$OPKG_REPO_DIR" ]; then
          echo "ERROR: Package repository storage $OPKG_REPO_DIR not found"
          echo "Please ensure storage is mounted at /mnt/opkg-repo"
          exit 1
        fi
        
        # Clean up any leftover containers and images from previous builds
        docker system prune -f || true
        
        # Show disk space before build
        df -h

    - name: Determine feed configuration
      id: feed-config
      run: |
        # Get distro codename for all scenarios
        DISTRO_CODENAME=$(./kas-container shell ${{ matrix.kas_file }} -c "bitbake -e | grep '^DISTRO_CODENAME=' | cut -d'\"' -f2")
        
        if [ "${{ github.ref_name }}" = "main" ]; then
          # Use distro codename for stable releases (e.g., walnascar, scarthgap)
          echo "feed_name=${DISTRO_CODENAME}" >> $GITHUB_OUTPUT
          echo "subfolder=continuous" >> $GITHUB_OUTPUT
          echo "is_prerelease=false" >> $GITHUB_OUTPUT
          echo "is_tagged_release=false" >> $GITHUB_OUTPUT
          echo "is_published_branch=true" >> $GITHUB_OUTPUT
          echo "distro_codename=${DISTRO_CODENAME}" >> $GITHUB_OUTPUT
          echo "feed_subfolder=continuous" >> $GITHUB_OUTPUT
        elif [ "${{ github.ref_name }}" = "develop" ]; then
          # Use "develop" for all development builds
          echo "feed_name=develop" >> $GITHUB_OUTPUT
          echo "subfolder=continuous" >> $GITHUB_OUTPUT
          echo "is_prerelease=false" >> $GITHUB_OUTPUT
          echo "is_tagged_release=false" >> $GITHUB_OUTPUT
          echo "is_published_branch=true" >> $GITHUB_OUTPUT
          echo "distro_codename=develop" >> $GITHUB_OUTPUT
          echo "feed_subfolder=continuous" >> $GITHUB_OUTPUT
        elif [[ "${{ github.ref }}" =~ ^refs/tags/ ]]; then
          # Tagged releases - publish to release folder
          echo "feed_name=${DISTRO_CODENAME}" >> $GITHUB_OUTPUT
          echo "subfolder=release" >> $GITHUB_OUTPUT
          echo "is_published_branch=true" >> $GITHUB_OUTPUT
          echo "distro_codename=${DISTRO_CODENAME}" >> $GITHUB_OUTPUT
          echo "feed_subfolder=release" >> $GITHUB_OUTPUT
          # Check if this is a prerelease (contains rc, beta, or alpha)
          if [[ "${{ github.ref_name }}" =~ (rc|beta|alpha) ]]; then
            echo "is_prerelease=true" >> $GITHUB_OUTPUT
          else
            echo "is_prerelease=false" >> $GITHUB_OUTPUT
          fi
          echo "is_tagged_release=true" >> $GITHUB_OUTPUT
        else
          # Pull requests or other refs - don't publish
          echo "feed_name=${DISTRO_CODENAME}" >> $GITHUB_OUTPUT
          echo "subfolder=branch" >> $GITHUB_OUTPUT
          echo "is_prerelease=false" >> $GITHUB_OUTPUT
          echo "is_tagged_release=false" >> $GITHUB_OUTPUT
          echo "is_published_branch=false" >> $GITHUB_OUTPUT
          echo "distro_codename=${DISTRO_CODENAME}" >> $GITHUB_OUTPUT
          echo "feed_subfolder=continuous" >> $GITHUB_OUTPUT
        fi
        
        echo "Feed configuration complete"
        echo "Image will use feed: https://opkg.calculinux.org/ipk/$(cat $GITHUB_OUTPUT | grep distro_codename | cut -d'=' -f2)/$(cat $GITHUB_OUTPUT | grep feed_subfolder | cut -d'=' -f2)/"

    - name: Configure package feed for image
      run: |
        echo "Configuring package feed..."
        
        DISTRO_CODENAME="${{ steps.feed-config.outputs.distro_codename }}"
        FEED_SUBFOLDER="${{ steps.feed-config.outputs.feed_subfolder }}"
        
        # Create build/conf directory if it doesn't exist
        mkdir -p build/conf
        
        # Create auto.conf to override feed configuration
        cat > build/conf/auto.conf << EOF
        # Auto-generated feed configuration for CI builds
        # This file is created by the GitHub Actions workflow
        
        # Override DISTRO_CODENAME for develop builds
        DISTRO_CODENAME = "${DISTRO_CODENAME}"
        
        # Set the feed subfolder (continuous or release)
        CALCULINUX_FEED_SUBFOLDER = "${FEED_SUBFOLDER}"
        
        # Resulting feed path: https://opkg.calculinux.org/ipk/${DISTRO_CODENAME}/${FEED_SUBFOLDER}/
        EOF
        
        echo "Package feed configured:"
        echo "  DISTRO_CODENAME = ${DISTRO_CODENAME}"
        echo "  CALCULINUX_FEED_SUBFOLDER = ${FEED_SUBFOLDER}"
        echo "  Full feed URL: https://opkg.calculinux.org/ipk/${DISTRO_CODENAME}/${FEED_SUBFOLDER}/"

    - name: Build Yocto image and packages
      run: |
        echo "Building ${{ matrix.name }} using ${{ matrix.kas_file }}"
        echo "This will build:"
        echo "  - ${{ matrix.target }} (base image with overlayfs)"
        echo "  - packagegroup-meta-calculinux-apps (IPK packages)"
        echo ""
        echo "All packages install to /usr (standard paths)"
        echo "Runtime: /usr is overlayfs - base in lower layer, user packages in upper layer"
        
        # Run the build with kas-container
        ./kas-container build ${{ matrix.kas_file }}

    - name: Collect build artifacts (images)
      run: |
        echo "Collecting build artifacts..."
        
        # Find the build directory
        BUILD_DIR=$(find build -name "tmp" -type d | head -1 | sed 's|/tmp||')
        DEPLOY_DIR="${BUILD_DIR}/tmp/deploy/images/${{ matrix.machine }}"
        
        echo "Deploy directory: $DEPLOY_DIR"
        
        if [ -d "$DEPLOY_DIR" ]; then
          # Create artifacts directory
          mkdir -p artifacts
          
          # Copy image files
          find "$DEPLOY_DIR" -name "*.wic.gz" -o -name "*.wic.bz2" -o -name "*.wic.xz" | \
            xargs -I {} cp {} artifacts/ || true
          
          # Copy update bundles (RAUC bundles)
          find "$DEPLOY_DIR" -name "*.raucb" | \
            xargs -I {} cp {} artifacts/ || true
          
          # Copy u-boot files
          cp "$DEPLOY_DIR/uboot-${{ matrix.machine }}-*.bin" artifacts/ || true
          cp "$DEPLOY_DIR/u-boot-*initial-env-${{ matrix.machine }}-*" artifacts/ || true
          
          # Copy other important files
          find "$DEPLOY_DIR" -name "*.manifest" -o -name "*.testdata.json" | \
            xargs -I {} cp {} artifacts/ || true
          
          # List what we collected
          echo "Collected artifacts:"
          ls -la artifacts/
        else
          echo "Deploy directory not found: $DEPLOY_DIR"
          echo "Available directories:"
          find build -type d -name "deploy" || true
        fi

    - name: Collect build artifacts (packages)
      run: |
        echo "Collecting IPK packages..."
        
        # Find build directory
        BUILD_DIR=$(find build -name "tmp" -type d | head -1)
        DEPLOY_IPK_DIR="${BUILD_DIR}/deploy/ipk"
        
        if [ -d "$DEPLOY_IPK_DIR" ]; then
          PACKAGE_COUNT=$(find "$DEPLOY_IPK_DIR" -name "*.ipk" -type f | wc -l)
          echo "Found $PACKAGE_COUNT IPK packages"
          
          # Create packages directory in artifacts
          mkdir -p artifacts/packages
          
          # Copy all packages maintaining architecture structure
          cp -r "$DEPLOY_IPK_DIR"/* artifacts/packages/
          
          echo "Collected packages:"
          ls -la artifacts/packages/
        else
          echo "Warning: No IPK packages directory found"
        fi

    - name: Sync packages to repository
      if: steps.feed-config.outputs.is_published_branch == 'true'
      run: |
        echo "Syncing packages to repository..."
        
        FEED_NAME="${{ steps.feed-config.outputs.feed_name }}"
        SUBFOLDER="${{ steps.feed-config.outputs.subfolder }}"
        IS_TAGGED_RELEASE="${{ steps.feed-config.outputs.is_tagged_release }}"
        
        # Determine feed path based on branch/tag
        if [ "$IS_TAGGED_RELEASE" = "true" ]; then
          # Tagged releases go to ipk/{codename}/release/
          FEED_PATH="ipk/${FEED_NAME}/${SUBFOLDER}"
          echo "Publishing to release feed: $FEED_PATH"
        elif [ "${{ github.ref_name }}" = "main" ]; then
          # Main branch goes to ipk/{codename}/continuous/
          FEED_PATH="ipk/${FEED_NAME}/${SUBFOLDER}"
          echo "Publishing to stable feed: $FEED_PATH"
        elif [ "${{ github.ref_name }}" = "develop" ]; then
          # Develop goes to ipk/develop/continuous/
          FEED_PATH="ipk/${FEED_NAME}/${SUBFOLDER}"
          echo "Publishing to development feed: $FEED_PATH"
        else
          echo "ERROR: Unexpected branch/tag configuration"
          exit 1
        fi
        
        # Create target directory
        FEED_DIR="$OPKG_REPO_DIR/$FEED_PATH"
        mkdir -p "$FEED_DIR"
        
        # Determine sync strategy based on workflow input
        SYNC_ALL="${{ inputs.sync_all_packages }}"
        if [ "$SYNC_ALL" = "true" ]; then
          echo "Syncing ALL packages (manual full sync requested)"
          BUILD_START_TIME=0
        else
          # Record the build start time (subtract 5 minutes for safety margin)
          BUILD_START_TIME=$(date -d '5 minutes ago' +%s)
          echo "Only syncing packages modified after: $(date -d @$BUILD_START_TIME)"
        fi
        
        # Sync packages
        SYNCED=0
        SKIPPED=0
        
        if [ -d "artifacts/packages" ]; then
          for arch_dir in artifacts/packages/*/; do
            if [ -d "$arch_dir" ]; then
              arch=$(basename "$arch_dir")
              arch_dir_target="$FEED_DIR/$arch"
              
              mkdir -p "$arch_dir_target"
              echo "Processing architecture: $arch"
              
              # Process all packages
              while IFS= read -r -d '' ipk_file; do
                package_name=$(basename "$ipk_file")
                target_file="$arch_dir_target/$package_name"
                file_mtime=$(stat -c %Y "$ipk_file")
                
                # Sync if package is newly built OR missing from target
                if [ "$file_mtime" -ge "$BUILD_START_TIME" ] || [ ! -f "$target_file" ]; then
                  if [ "$file_mtime" -ge "$BUILD_START_TIME" ]; then
                    echo "  Syncing newly built package: $package_name"
                  else
                    echo "  Syncing missing package: $package_name"
                  fi
                  cp "$ipk_file" "$arch_dir_target/"
                  SYNCED=$((SYNCED + 1))
                else
                  SKIPPED=$((SKIPPED + 1))
                fi
              done < <(find "$arch_dir" -name "*.ipk" -type f -print0)
              
              # Copy package indexes if they exist
              if [ -f "$arch_dir/Packages" ]; then
                echo "  Copying package index for $arch"
                cp "$arch_dir/Packages" "$arch_dir_target/"
              fi
              if [ -f "$arch_dir/Packages.gz" ]; then
                cp "$arch_dir/Packages.gz" "$arch_dir_target/"
              fi
            fi
          done
          
          echo "Packages synced: $SYNCED (newly built)"
          echo "Packages skipped: $SKIPPED (from sstate-cache)"
          echo "Total available: $((SYNCED + SKIPPED))"
          
          # Show package counts by architecture
          for arch_dir in "$FEED_DIR"/*/; do
            if [ -d "$arch_dir" ]; then
              arch=$(basename "$arch_dir")
              count=$(find "$arch_dir" -name "*.ipk" -type f | wc -l)
              size=$(du -sh "$arch_dir" | cut -f1)
              echo "  $arch: $count packages ($size)"
            fi
          done
          
          echo "Packages available at: https://opkg.calculinux.org/$FEED_PATH/"
        else
          echo "Warning: No packages found to sync"
        fi

    - name: Generate package indexes
      if: steps.feed-config.outputs.is_published_branch == 'true'
      run: |
        FEED_NAME="${{ steps.feed-config.outputs.feed_name }}"
        SUBFOLDER="${{ steps.feed-config.outputs.subfolder }}"
        IS_TAGGED_RELEASE="${{ steps.feed-config.outputs.is_tagged_release }}"
        
        # Determine feed path (same logic as sync step)
        if [ "$IS_TAGGED_RELEASE" = "true" ]; then
          FEED_PATH="ipk/${FEED_NAME}/${SUBFOLDER}"
        elif [ "${{ github.ref_name }}" = "main" ]; then
          FEED_PATH="ipk/${FEED_NAME}/${SUBFOLDER}"
        elif [ "${{ github.ref_name }}" = "develop" ]; then
          FEED_PATH="ipk/${FEED_NAME}/${SUBFOLDER}"
        else
          echo "ERROR: Unexpected branch/tag configuration"
          exit 1
        fi
        
        FEED_DIR="$OPKG_REPO_DIR/$FEED_PATH"
        
        echo "Generating Packages.gz files for feed: $FEED_PATH"
        
        for arch_dir in "$FEED_DIR"/*/; do
          if [ -d "$arch_dir" ]; then
            arch=$(basename "$arch_dir")
            echo "Generating Packages.gz for architecture: $arch"
            
            cd "$arch_dir"
            
            # Generate Packages file
            opkg-make-index -p Packages .
            
            # Compress to Packages.gz
            gzip -f Packages
            
            # Verify the file was created
            if [ -f "Packages.gz" ]; then
              echo "  Successfully generated Packages.gz for $arch"
            else
              echo "  ERROR: Failed to generate Packages.gz for $arch"
              exit 1
            fi
            
            cd - > /dev/null
          fi
        done
        
        echo "Package index generation complete"

    - name: Publish images to webserver
      if: steps.feed-config.outputs.is_published_branch == 'true'
      run: |
        echo "Publishing images to webserver..."
        
        FEED_NAME="${{ steps.feed-config.outputs.feed_name }}"
        SUBFOLDER="${{ steps.feed-config.outputs.subfolder }}"
        UPDATE_DIR="$OPKG_REPO_DIR/update/$FEED_NAME/$SUBFOLDER"
        IMAGE_DIR="$OPKG_REPO_DIR/image/$FEED_NAME/$SUBFOLDER"
        IS_TAGGED_RELEASE="${{ steps.feed-config.outputs.is_tagged_release }}"
        IS_PRERELEASE="${{ steps.feed-config.outputs.is_prerelease }}"
        TAG_NAME="${{ github.ref_name }}"
        
        # Create target directories
        mkdir -p "$UPDATE_DIR" "$IMAGE_DIR"
        
        if [ "$IS_TAGGED_RELEASE" = "true" ]; then
          echo "Publishing tagged release images..."
          
          # Find the specific RAUC bundle and WIC image files
          RAUCB_FILE=$(find artifacts -name "calculinux-bundle-${{ matrix.machine }}.raucb" | head -1)
          WIC_FILE=$(find artifacts -name "calculinux-image-${{ matrix.machine }}.rootfs.wic.gz" | head -1)
          
          if [ -n "$RAUCB_FILE" ]; then
            # Copy RAUC bundle with versioned name
            cp "$RAUCB_FILE" "$UPDATE_DIR/calculinux-bundle-${{ matrix.machine }}-$TAG_NAME.raucb"
            echo "Published RAUC bundle: calculinux-bundle-${{ matrix.machine }}-$TAG_NAME.raucb"
            
            # If not a prerelease, also copy with original name for latest release
            if [ "$IS_PRERELEASE" = "false" ]; then
              cp "$RAUCB_FILE" "$UPDATE_DIR/calculinux-bundle-${{ matrix.machine }}.raucb"
              echo "Published RAUC bundle: calculinux-bundle-${{ matrix.machine }}.raucb (latest)"
            fi
          else
            echo "Warning: calculinux-bundle-${{ matrix.machine }}.raucb not found"
          fi
          
          if [ -n "$WIC_FILE" ]; then
            # Copy WIC image with versioned name
            cp "$WIC_FILE" "$IMAGE_DIR/calculinux-image-${{ matrix.machine }}.rootfs-$TAG_NAME.wic.gz"
            echo "Published WIC image: calculinux-image-${{ matrix.machine }}.rootfs-$TAG_NAME.wic.gz"
            
            # If not a prerelease, also copy with original name for latest release
            if [ "$IS_PRERELEASE" = "false" ]; then
              cp "$WIC_FILE" "$IMAGE_DIR/calculinux-image-${{ matrix.machine }}.rootfs.wic.gz"
              echo "Published WIC image: calculinux-image-${{ matrix.machine }}.rootfs.wic.gz (latest)"
            fi
          else
            echo "Warning: calculinux-image-${{ matrix.machine }}.rootfs.wic.gz not found"
          fi
        else
          echo "Publishing continuous development images..."
          
          # Copy RAUC bundles to update directory
          if ls artifacts/*.raucb 1> /dev/null 2>&1; then
            echo "Copying RAUC bundles to $UPDATE_DIR"
            cp artifacts/*.raucb "$UPDATE_DIR/"
            echo "Published RAUC bundles:"
            ls -la "$UPDATE_DIR"/*.raucb
          else
            echo "No RAUC bundles found to publish"
          fi
          
          # Copy WIC images to image directory
          if ls artifacts/*.wic.gz 1> /dev/null 2>&1; then
            echo "Copying WIC images to $IMAGE_DIR"
            cp artifacts/*.wic.gz "$IMAGE_DIR/"
            echo "Published WIC images:"
            ls -la "$IMAGE_DIR"/*.wic.gz
          else
            echo "No WIC images found to publish"
          fi
        fi

        echo "Images published successfully"

    - name: Generate build information
      run: |
        # Create build info file
        cat > artifacts/build-info.txt << EOF
        Build Information
        =================
        Repository: ${{ github.repository }}
        Commit: ${{ github.sha }}
        Branch/Tag: ${{ github.ref_name }}
        Build Date: $(date -u)
        Configuration: ${{ matrix.name }}
        Machine: ${{ matrix.machine }}
        Target: ${{ matrix.target }}
        Kas File: ${{ matrix.kas_file }}
        Dockerfile: ${{ matrix.dockerfile }}
        Workflow: ${{ github.workflow }}
        Run Number: ${{ github.run_number }}
        EOF
        
        # Add git information if available
        if git log -1 --format="%H %s" >> artifacts/build-info.txt 2>/dev/null; then
          echo "Last Commit: $(git log -1 --format='%H %s')" >> artifacts/build-info.txt
        fi

    - name: Upload artifacts
      uses: actions/upload-artifact@v4
      if: always()
      with:
        name: calculinux-${{ matrix.machine }}-${{ github.run_number }}
        path: |
          artifacts/calculinux-bundle-${{ matrix.machine }}-*.raucb
          artifacts/calculinux-image-${{ matrix.machine }}.rootfs-*.wic.gz
          artifacts/uboot-${{ matrix.machine }}-*.bin
          artifacts/u-boot-*initial-env-${{ matrix.machine }}-*
        retention-days: 30

    - name: Comment artifact links on PR
      if: ${{ github.event_name == 'pull_request' }}
      uses: actions/github-script@v7
      with:
        github-token: ${{ secrets.GITHUB_TOKEN }}
        script: |
          try {
            const runId = context.runId;
            const { owner, repo } = context.repo;
            const issueNumber = context.payload.pull_request.number;

            core.info(`Attempting to comment on PR #${issueNumber} for run ${runId}`);

            const artifactsResponse = await github.rest.actions.listWorkflowRunArtifacts({
              owner,
              repo,
              run_id: runId,
              per_page: 100,
            });

            const artifacts = artifactsResponse.data.artifacts ?? [];
            core.info(`Found ${artifacts.length} artifacts`);

            if (artifacts.length === 0) {
              core.info('No artifacts found for this run; skipping PR comment.');
              return;
            }

            const formatSize = (bytes) => {
              if (!bytes || bytes <= 0) {
                return 'size unknown';
              }
              const mb = bytes / (1024 * 1024);
              return `${mb.toFixed(mb >= 10 ? 1 : 2)} MB`;
            };

            const artifactLines = artifacts
              .map((artifact) => `- [${artifact.name}](${artifact.archive_download_url}) (${formatSize(artifact.size_in_bytes)})`)
              .join('\n');

            const runUrl = `https://github.com/${owner}/${repo}/actions/runs/${runId}`;
            const body = `<!-- calculinux-artifacts -->\nðŸ“¦ **Build artifacts for this run:** [view logs and details](${runUrl})\n\n${artifactLines}`;

            // Check for existing comments
            core.info('Checking for existing artifact comments...');
            const existingComments = await github.paginate(
              github.rest.issues.listComments,
              {
                owner,
                repo,
                issue_number: issueNumber,
                per_page: 100,
              },
              (response) => response.data.filter((comment) => comment.body?.startsWith('<!-- calculinux-artifacts -->'))
            );

            if (existingComments.length > 0) {
              const commentToUpdate = existingComments[0];
              core.info(`Updating existing comment (ID: ${commentToUpdate.id})`);
              await github.rest.issues.updateComment({
                owner,
                repo,
                comment_id: commentToUpdate.id,
                body,
              });
              core.info(`âœ… Updated existing artifacts comment (ID: ${commentToUpdate.id}).`);
            } else {
              core.info('Creating new artifact comment...');
              const newComment = await github.rest.issues.createComment({
                owner,
                repo,
                issue_number: issueNumber,
                body,
              });
              core.info(`âœ… Created new artifacts comment (ID: ${newComment.data.id}).`);
            }
          } catch (error) {
            core.error(`âŒ Failed to comment on PR: ${error.message}`);
            core.error(`Error details: ${JSON.stringify(error, null, 2)}`);
            
            // Don't fail the entire workflow for comment failures
            core.warning('PR comment failed, but continuing workflow execution');
          }

    - name: Create release
      if: steps.feed-config.outputs.is_tagged_release == 'true'
      uses: softprops/action-gh-release@v1
      with:
        files: artifacts/*
        generate_release_notes: true
        draft: false
        prerelease: ${{ steps.feed-config.outputs.is_prerelease == 'true' }}

    - name: Send Discord notification
      if: steps.feed-config.outputs.is_tagged_release == 'true' && success()
      env:
        DISCORD_WEBHOOK_URL: ${{ secrets.DISCORD_WEBHOOK_URL }}
      run: |
        # Skip notification if Discord webhook is not configured
        if [ -z "$DISCORD_WEBHOOK_URL" ]; then
          echo "Discord webhook not configured, skipping notification"
          exit 0
        fi
        
        # For tagged releases only
        IS_PRERELEASE="${{ steps.feed-config.outputs.is_prerelease }}"
        TAG_NAME="${{ github.ref_name }}"
        COMMIT_SHA="${{ github.sha }}"
        RELEASE_URL="https://github.com/${{ github.repository }}/releases/tag/$TAG_NAME"
        
        # Set notification color and build type based on tag
        if [ "$IS_PRERELEASE" = "true" ]; then
          # Determine prerelease type
          if [[ "$TAG_NAME" =~ alpha ]]; then
            BUILD_TYPE="Alpha Release"
            COLOR="16776960"  # Yellow
          elif [[ "$TAG_NAME" =~ beta ]]; then
            BUILD_TYPE="Beta Release"
            COLOR="16753920"  # Orange
          elif [[ "$TAG_NAME" =~ rc ]]; then
            BUILD_TYPE="Release Candidate"
            COLOR="8421504"   # Gray
          else
            BUILD_TYPE="Pre-release"
            COLOR="16776960"  # Yellow
          fi
        else
          BUILD_TYPE="Stable Release"
          COLOR="65280"     # Green
        fi
        
        VERSION="$TAG_NAME"
        DOWNLOAD_BASE="https://opkg.calculinux.org"
        IMAGE_URL="$DOWNLOAD_BASE/image/${{ steps.feed-config.outputs.feed_name }}/release/"
        UPDATE_URL="$DOWNLOAD_BASE/update/${{ steps.feed-config.outputs.feed_name }}/release/"
        PACKAGES_URL="$DOWNLOAD_BASE/ipk/${{ steps.feed-config.outputs.feed_name }}/release/"
        
        # Find actual build artifacts
        WIC_FILE=$(find artifacts -name "calculinux-image-${{ matrix.machine }}*.wic.gz" | head -1)
        RAUCB_FILE=$(find artifacts -name "calculinux-bundle-${{ matrix.machine }}*.raucb" | head -1)
        
        # Create download links section for tagged releases
        DOWNLOAD_LINKS=""
        if [ -n "$WIC_FILE" ]; then
          WIC_FILENAME=$(basename "$WIC_FILE")
          WIC_VERSIONED="${WIC_FILENAME%.wic.gz}-$TAG_NAME.wic.gz"
          DOWNLOAD_LINKS="${DOWNLOAD_LINKS}ðŸ“± **Full Image**: [$WIC_VERSIONED]($IMAGE_URL$WIC_VERSIONED)\n"
        fi
        if [ -n "$RAUCB_FILE" ]; then
          RAUCB_FILENAME=$(basename "$RAUCB_FILE")
          RAUCB_VERSIONED="${RAUCB_FILENAME%.raucb}-$TAG_NAME.raucb"
          DOWNLOAD_LINKS="${DOWNLOAD_LINKS}ðŸ”„ **Update Bundle**: [$RAUCB_VERSIONED]($UPDATE_URL$RAUCB_VERSIONED)\n"
        fi
        
        # Add package feed link
        DOWNLOAD_LINKS="${DOWNLOAD_LINKS}ðŸ“¦ **Package Feed**: [Browse packages]($PACKAGES_URL)\n"
        
        # Create Discord embed payload
        cat > discord_payload.json << EOF
        {
          "embeds": [
            {
              "title": "ðŸš€ New Calculinux $BUILD_TYPE Available!",
              "description": "A new Calculinux build has been published for **${{ matrix.machine }}**",
              "color": $COLOR,
              "fields": [
                {
                  "name": "ðŸ“‹ Version",
                  "value": "$VERSION",
                  "inline": true
                },
                {
                  "name": "ðŸ·ï¸ Build Type",
                  "value": "$BUILD_TYPE",
                  "inline": true
                },
                {
                  "name": "ðŸ’» Target Device",
                  "value": "${{ matrix.machine }}",
                  "inline": true
                },
                {
                  "name": "ðŸ“¥ Downloads",
                  "value": "$DOWNLOAD_LINKS",
                  "inline": false
                }
              ],
              "footer": {
                "text": "Build #${{ github.run_number }} â€¢ Calculinux"
              },
              "timestamp": "$(date -u +%Y-%m-%dT%H:%M:%S.000Z)",
              "url": "$RELEASE_URL"
            }
          ]
        }
        EOF
        
        # Send Discord notification
        echo "Sending Discord notification for $BUILD_TYPE..."
        HTTP_CODE=$(curl -s -o discord_response.json -w "%{http_code}" \
          -H "Content-Type: application/json" \
          -d @discord_payload.json \
          "$DISCORD_WEBHOOK_URL")
        
        if [ "$HTTP_CODE" -eq 204 ]; then
          echo "âœ… Discord notification sent successfully"
        else
          echo "âŒ Failed to send Discord notification (HTTP $HTTP_CODE)"
          echo "Response:"
          cat discord_response.json || echo "No response body"
          exit 1
        fi

    - name: Show disk space after build
      if: always()
      run: |
        echo "Disk space after build:"
        df -h
        
        echo "Cache directory sizes:"
        du -sh $DL_DIR $SSTATE_DIR || true

    - name: Cleanup
      if: always()
      run: |
        # Clean up build directory but preserve caches
        rm -rf build/tmp/work/* || true
        
        # Clean up docker containers and images
        docker system prune -f || true
        
        # Remove our custom image to save space
        docker rmi kas-custom:latest || true
